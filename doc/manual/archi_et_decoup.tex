\chapter{Architecture et découpage en bloc}
\authors{
  \authorinfo{Romain}{Marchaudon}\\
  \authorinfo{Marc}{de la Motte Rouge}
}

Pour débuter notre projet sur la réalisation du cockpit, nous avons eu besoin de positionner les différents éléments de notre travail dans "l'univers Flight Simulator". En effet, les données sont extraites différemment selon leurs types. Les données concernant l'affichage sur les écrans passent par le logiciel WideView. Les données concernant les paramètres réglables ou à communiquer à l'utilisateur par différents afficheurs (autre que celles simulées par les écrans) passent par le logiciel FSUIPC. Il a donc fallu réaliser une surcouche logiciel afin de pouvoir dialoguer avec ce dernier. 

\section{Architecture générale}

Le positionnement de notre projet par rapport à l'univers de Flight Simulator est détaillé sur la figure \ref{fig:position}.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.7]{images/positionnement}
  }
  \caption{Positionnement du projet dans l'univers Flight Simulator}
  \label{fig:position}
\end{figure}

Par la suite, nous avons recherché des informations sur chaque partie à réaliser. Pour cela, nous avons organisé des 
groupes de travail au sein de l'équipe, chaque groupe étant responsable d'un bloc.

Nous avons découpé la réalisation technique du projet en quatre grandes parties :

\begin{description}
\item [Tâche 1 :] Recherche générale sur le projet, information sur les projets de ce type déjà réalisés ;
\item [Tâche 2 :] Commande de pilotage, puissance  (cette partie comprend l'asservissement des commandes) ;
\item [Tâche 3 :] Monde extérieur et réseaux ;
\item [Tâche 4 :] Interface Homme Machine (IHM) et extraction des données de Microsoft Flight Simulator X (FSX) ;
\item [Tâche 5 :] Saisie des données, commande (vitesse, cap etc...).
\end{description}

Ces tâches sont répartis dans le cockpit selon la figure \ref{fig:decoup1}.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.7]{images/decoup1}
  }
  \caption{Découpage des parties en début de projet}
  \label{fig:decoup1}
\end{figure}

\section{Découpage}

Ce découpage a été déterminé selon les catégories d'instruments à réaliser. Les affichages par exemple ont été séparés selon leurs fonctions: ceux qui affichent le monde exterieure, sur lequel nous avions uniquement les paramètres de configuration des affichages à modifier pour gérer l'angle de vue des différents écrans par exemple ont fait l'objet d'une étude particulière par une sous-équipe du projet. Les écrans qui affichent les instruments de bord, distincts de l'affichage du monde extérieur ont fait l'objet d'une étude 
distincte également.

La partie qui concerne les commandes de gaz fait appel à des servo-moteurs  qui peutvent être commandés avec des données prétraitée comme une position ou un angle. En effet, c'est la seul partie qui utilise ce type de technologie.

Nous avons également réalisé une partie permettant de gérer des composants tels que les interrupteurs, les potentiomètres, 
les afficheurs et les commutateurs. Enfin, l'interfaçage logiciel avec Flight Simulator a également été étudié.

Ce découpage a été réalisé selon des regroupements fonctionnels. Il couvrait les différentes parties du cockpit. Il a été fortement modifié par la suite. En effet, nous ne pouvions pas réaliser toutes ces parties simultanément, il a été nécessaire de nous recentrer sur certaines parties. Ce découpage a été réalisé pour l'état de l'art, celui utilisé pour le développement est différent, il sera étudié ultérieurement.

\section{Choix techniques et technologiques}
Après avoir étudié les tâches à réaliser et les différentes solutions envisageable,
nous avons choisi des solutions validées par nos professeurs. Nous nous sommes servi de l'état de l'art réalisé en amont pour définir nos choix. Cependant, les autres projets mettent souvent en avant l'aspect visuel et se positionne du point de vue \emph{human in the
loop} en utilisant des modules déja existant. Cela n'était pas notre objectif, nous souhaitions faire du \emph{hardware in the loop}.  Nous avons donc créé nos propres composants.

\subsection{L'appareil}
Une des premières décision que nous avons eu à prendre concernait le choix du modèle d'avion utilisé pour le projet. En effet, lors de la 
présentation, il avait été décidé que l'Airbus A 320 serait utilisé. Cependant, sur certains types d'appareils, FSUIPC \footnote{FSUIPC 
est une librairie dynamique donnant accès aux variables de Fligh Simulator et permettant leur modification.} ne retourne aucune donnée. 
Il était donc nécessaire de choisir un appareil où l'on pouvait accèder au maximum de données. Dans le cas de l'Airbus A 320, la 
modélisation la plus proche était WILCO \footnote{WILCO est une société produisant des répliques d'éléments extérieurs d'avion.}, avec 
l'utilisation de brique MAGENTA \footnote{MAGENTA est une société developpant des logiciels et matériels pour le domaine de la simulation 
aéronautique.}. Cette solution est très réaliste car très proche de la 
réalité, mais pose des problèmes d'interfaçages avec FSUIPC. Nous avons finalement choisi de basculer de Flight Simulator 2004 à Flight 
Simulator X. Celui-ci est légèrement plus cher et nécessite des ressources plus importantes, toutefois, il contient un modèle d'aribus 
A321, très proche de l'A320 et permet d'extraire les données d'FSUIPC.

\subsection{Les bus de données}

L'équipe avait envisagé d'utiliser différents type de bus selon les parties à traiter avec notamment du CAN, de l'I$^2$C, du LIN et de l'Ethernet.  Le bus LIN avait été retenu car il est très présent dans  les industries automobiles et aéronautiques et rentre donc dans le cadre de notre projet. Cependant, nous ne sommes pas assez nombreux pour développer quatre architectures de bus différentes. Le LIN est utilisé dans l'industrie uniquement pour des raisons économiques, car contrairement au CAN, il ne s'agit pas d'un protocole propriétaire, il n'y a donc pas de droits à payer pour l'implanter. C'est son seul avantage dans notre contexte, il n'a donc pas été utilisé dans ce projet. En interne, chaque brique (module CAN) communique en I$^2$C. Ces signaux sont ensuite convertis pour s'adapter au CAN qui relie l'ensemble des éléments. Enfin, les affichages issus directement de Microsoft Flight Simulator X utilisent de l'Ethernet pour l'affichage de WideView. Les servo-moteurs (leur choix sera détaillé dans la partie ci-dessous) de la commande des gaz sont reliés en série en RS232.

\subsection{La partie commande de gaz}

Les commandes de gaz sont à la fois capteurs et actionneurs. En effet, en pilotage manuel, elles servent à régler la vitesse choisie, en pilotage automatique, leur position doit évoluer en fonction de la vitesse imposée par de dernier. De plus, nous souhaitions pouvoir désactiver le pilote automatique et reprendre le contrôle de l'avion par une simple pression sur la poignée. Nous avons donc cherché un composant capable de détecter également le couple imposé.

Nous avons choisie d'utiliser des servo-moteurs AX12 de Bioloid. Cet élément est disponible en une version compatible avec le bus CAN, cela permet de garder une architecture homogène. Il a également une interface série. Cela permet de placer plusieurs éléments à la suite sur un seul bus. Il fonctionne en maître / esclave avec deux types de commandes, une en interrogation - une en action. Parmis les commandes disponiblent sur ce composant, on trouve notamment la position, le couple ou la détection de couple (utile pour le dépassement). De plus, lors de l'accélération d'un avion réel, il y a un délai d'environ cinq secondes entre le mouvement sur la manette et la poussé des moteurs. Ce délai est très largement supérieur à ceux nécassaire en électronique. Nous n'avons donc pas de contrainte de vitesse sur ce composant.

Cet élément permet donc d'acquérir une donnée, mais également de s'adapter à la consigne fixée par le pilote automatique.

\subsection{L'affichage des instruments}
Pour l'affichage de certaines parties, nous souhaitions tout réaliser avec des écrans, cependant la présence de boutons comme des interrupteurs, potentiomètre etc... au milieu a posé problèmes. Il a donc été nécessaire de ré-étudier le positionnement des écrans du glass-cockpit \footnote{Glass-cockpit: affichage numérique des instruments de vol. Ceci sont dupliqués avec les
instruments analogiques.}.

Pour les afficheurs du MCP \footnote{MCP: panel central où se trouve les instruments du pilote automatique.}, 
l'équipe avait proposée d'utiliser des afficheurs LCD afin de réaliser un bloc générique qui peut s'adapter à tous les affichages 
nécessaires, quelque soit le nombre de chiffres à afficher (et donc le nombre de bits d'entrées).  Mr Bouaziz, notre tuteur, a souhaité 
qu'une brique de base avec cinq afficheurs sept segements  soit réalisée (certains seront retirés ou cachés pour les applications 
nécessitant  moins d'afficheurs). Le circuit SA1064 a été sélectionné pour réaliser cette fonctionnalité avec le module CAN associé. Il 
présente une interface LCD avec des afficheurs sept segements. Ces afficheurs sont reliés en I$^2$C.

Par ailleurs, l'overhead \footnote{Overhead: panel supérieur du cockpit où se trouve des capteurs et des actionneurs contrôlant les 
paramètres de l'avion.} n'a pas été réalisé. L'équipe avait envisagé de le réalisé à l'aide d'écran tactile. Cependant sa mise en place 
était trop compliquée pour l'intégrer au projet dés cette année.

\subsection{Le monde extérieur}

Pour afficher le monde extérieur, l'équipe avait proposé d'utiliser des projecteurs. Cette solution présentait l'avantage d'être moins 
coûteuse, facilement transportable et s'avèrait surtout moins destructrice pour la vues des personnes se trouvant dans le cockpit en ne 
plaçant pas d'écrans à proximité des yeux. Cependant, cette solution présentait l'inconvénient d'obliger à déformer l'image, ce que ne 
permet pas WidevieW \footnote{WideView: logiciel permettant d'afficher sur plusieurs écrans différentes vues issues d'un même 
ordinateur.}. Il a finalement été décidé d'utiliser des écrans 24 pouces (ou éventuellement 32 pouces) pour former la vue panoramique .

\subsection{Les ordinateurs}

Afin de faire fonctionner Microsoft Flight Simulator X sur plusieurs écrans et de pouvoir interfacer le programme vec l'ensemble des
éléments du cockpit, nous avons du choisir le nombre de machines ainsi que leur configuration.
Dans un premier temps nous nous sommes occupé de choisir le nombre de machines à acheter, pour cela
il a fallu déterminer le nombre d'écrans à utiliser auparavant. Sachant qu'il avait été décidé de ne faire que la partie
pilote du cokcpit et de délaisser la partie copilote, seulement une partie des instruments de bords avaient besoin
de disposer d'un moniteur capable de faire l'affichage. nous avons utilisé deux écrans pour afficher les instruments de bord.
Pour l'affichage du monde extérieur, il a été choisi d'utiliser un
ensemble de 4 écrans 24 pouces. nous avons donc interfacé 6 écrans au total.

Nous avons décidé d'utiliser des cartes graphiques d'une puissance assez importante en raison de la taille des écrans utilisés. De
plus, afin de limiter le coût des machines, nous avons fait le choix de n'utiliser qu'une seule carte graphique par
ordinateur, les configurations multicarte ayant un prix nettement plus important pour des performances d'affichage
qui peuvent baisser si le nombre d'écrans installé sur chaque PC est trop important.

Dans un deuxième temps il a fallu choisir le type de boitier a adopter. Le principal argument ayant orienté nore
choix réside dans l'espace requis pour les boitiers. En effet, une des priorités était de pouvoir déplacer le ockpit
pour faire des démonstrations, l'utilisation de PC en rack se trouvait beaucoup plus
intéressante que l'utilisation d'un boitier classique. De plus ceci permettait de mettre dans le rack le switch que nous avons utilisé pour faire communiquer les pc entre eux.

Afin de pouvoir supporter facilement la charge de travail imposée par Microsoft Flight Simulator X et ses programmes annexes (WideView, WideFS, FSUIPC),
nous avons décidé de configurer une machine avec un processeur quatre coeur, ainsi que deux autres machines avec
des processeurs double coeur s'occupant des affichages du monde exterrieur et des instruments de bords.

\section{Organisation}

Pour développer notre cockpit, nous avons établi des blocs fonctionnel, en fonction des éléments à réaliser. Ce découpage est réalisé selon la figure \ref{fig:schema_bloc}.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.7]{images/schema_bloc}
  }
  \caption{Schéma bloc}
  \label{fig:schema_bloc}
\end{figure}

Pour nous répartir le travail à réaliser, nous avons créé plusieurs sous-groupes au sein du projet. Chacun d'eux avait la responsabilité de développer une partie. Celles-ci correspondaient à une fonctionnalité de l'avion. Nous avons réalisé ce partage selon un découpage "horizontal", tel que montré sur la figure \ref{fig:decoup_horizontal}.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.7]{images/decoup_horizontal}
  }
  \caption{Découpage horizontal du projet}
  \label{fig:decoup_horizontal}
\end{figure}

Par la suite, nous avons abandonné ce système. Il ne permettait pas de réaliser des blocs fonctionnels réutilisables comme nous le souhaitions. En effet, ce système aurait nécessité que chaque sous-groupe développent sont interface avec le bus CAN par exemple. Il en est de meme pour plusieurs éléments. Pour cela, nous avons réalisé un nouveau découpage. Celui-ci sépare les tâches selon leur nature. Il permet de regrouper des fonctions identique entre elles. Ainsi chaque groupe est devenu responsable d'une fonction électronique au lieu d'une fonctionnalité de l'avion. Cette méthode nous a permis de développer des blocs génériques comme nous le souhaitions. Cette architecture permet de gagner en modularité. Elle facilite l'ajout de nouveaux éléments. Ce découpage est de type "vertical", il est détaillé sur la figure  \ref{fig:decoup_vertical}.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.7]{images/decoup_vertical}
  }
  \caption{Découpage vertical du projet}
  \label{fig:decoup_vertical}
\end{figure}
