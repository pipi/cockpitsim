\chapter{Architecture et découpage en bloc}
\authors{
  \authorinfo{prénom}{nom} \\
}


\section{Choix technologiques}
Après avoir étudié les tâches à réaliser et les différentes solutions envisageable, nous avons choisi des solutions en accord avec nos professeurs encadrant. Nous avons également observé les solutions existantes sur des projets de même type déjà aboutis. Cependant, ces projets sont souvent destinés au rendu visuel pour l'utilisateur et font appel à des solutions "complètes" pour certain modules. Nous recherchions le but pédagogique dans ce projet, nous avons donc réalisé nous mêmes ces modules. Nous ne nous somme donc pas engagés sur la même voix que ces applications. Les décisions prisent aux débuts du projet ont par la suite évoluées en fonction de l'avancement.

\subsection{L'appareil}
Une des premières décision que nous avons du prendre concernait le choix de l'avion utilisé pour le projet. En effet, lors de la présentation, il avait été décidé que l'Airbus A320 serait utilisé. Cependant, sur certains types d'appareils, FSUIPC ne retourne aucune donnée. Il était donc nécessaire de choisir un appareil où l'on pouvait accéder à un maximum de données. Pour l'Airbus A320, la modélisation la plus proche était WILCO, avec l'utilisation de brique MAGENTA. Cette solution est très réaliste, mais pose des problèmes d'interfaçages avec FSUIPC. Nous avons finalement choisi de basculer de Flight Simulator 2004 à Flight Simulator X. Celui-ci est légèrement plus cher et nécessite des ressources plus importantes. Toutefois, il contient un modèle d'Airbus A321, très proche de l'A320. Il permet également d'extraire les données de FSUIPC.

\subsection{Les bus de données}
L'équipe avait envisagé d'utiliser différents type de bus selon les parties à traiter avec notamment du CAN, de l'I2C, du LIN et de l'Ethernet.  Le bus LIN avait été retenu car il est très présent dans les industries automobiles et aéronautiques et rentre donc dans le cadre de notre projet. Cependant, nous ne sommes pas assez nombreux pour développer quatre architectures de bus différentes. Le LIN est utilisé dans l'industrie uniquement pour des raisons économiques, car contrairement au CAN, il ne s'agit pas d'un protocole propriétaire, il n'y a donc pas de droits à payer pour l'implanter. C'est le seul avantage du LIN, il n'a donc pas été utilisé dans ce projet. En interne, chaque brique communique en I2C. Ces signaux sont ensuite convertis pour s'adapter au CAN qui relie l'ensemble des éléments. Enfin, les affichages issus directement de Flight Simulator utilisent de l'Ethernet. Les servo-moteurs de la commande des gaz sont reliés en série en RS232.

\subsection{La partie Commande}

Les commandes de gaz sont à la fois capteurs et actionneurs. En effet, en pilotage manuel, elles servent à régler la vitesse choisie. En pilotage automatique, leur position doit évoluer en fonction de la vitesse imposée par le calculateur. De plus, nous souhaitions pouvoir désactiver le pilote automatique et reprendre le contrôle de l'avion par une simple pression sur la poignée. Nous avons donc cherché un composant capable de détecter également le couple imposé.

Nous avons choisi d'utiliser les servo-moteurs AX12 de Bioloid. Cet élément est disponible en une version compatible avec le bus CAN, ce qui permet de rester dans une normalisation afin d'éviter de se diversifier en protocole. Il a également une interface RS 232 TTL. Cela permet de placer plusieurs éléments en série. Il fonctionne en maître / esclave avec deux types de commandes, une en interrogation - une en action. Parmi les commandes disponibles sur ce composant, on trouve notamment la position, le couple ou la détection de couple (utile pour le dépassement). De plus, lors de l'accélération d'un avion réel, il y a un délai d'environ cinq secondes entre le mouvement sur la manette et la poussé des moteurs. Ce délai est très largement supérieur à ceux nécessaire en électronique. Nous n'avons donc pas de contrainte de vitesse sur ce composant.

Cet élément permet donc d'acquérir une donnée, mais également de s'adapter à la consigne fixée par le pilote automatique.

\subsection{Les affichages}
Pour l'affichage de certaine partie, nous souhaitions tous réaliser avec des écrans, cependant la présence de boutons comme des interrupteurs, potentiomètre etc... au milieu a posé problèmes. Il a donc été nécessaire de ré-étudier le positionnement des écrans du glass-cockpit.

Pour les afficheurs du MFC, l'équipe avait proposé d'utiliser des afficheurs LCD afin de réaliser un bloc "universel" qui peut s'adapter à tous les affichages nécessaires, quelque soit le nombre de chiffres à afficher (et donc le nombre de bits d'entrés).  Mr Bouaziz a souhaité qu'une brique de base avec cinq afficheurs multisegments soit réalisée (certains seront retirés ou cachés pour les applications nécessitant moins d'afficheurs). Le circuit 1064 a été sélectionné. Il présente une interface LCD avec des afficheurs multisegments. Ces afficheurs sont reliés en I2C.

L'overhead n'a pas été réalisé. L'équipe avait envisagé de le réaliser à l'aide d'écran tactile. Il est nécessaire d'étudier cette possibilité. Cependant, est-il possible de schématiser des potentiomètres sur des écrans tactiles ? Certains blocs de composant de l'overhead ont été commandés.

\subsection{Le monde extérieur}
Pour afficher le monde extérieur, l'équipe avait proposé d'utiliser des projecteurs. Cette solution présentait l'avantage d'être moins coûteuse, facilement transportable et s'avérait surtout moins destructrice pour la vues des personnes se trouvant dans le cockpit en ne plaçant pas des écrans à proximité des yeux. Cependant, cette solution présentait l'inconvénient d'obliger à déformer l'image, ce que ne permet pas Wide FS. Il a finalement été décidé d'utiliser des écrans 24 pouces, voir 32 pouces.

\subsection{Les ordinateurs}
Afin de faire fonctionner FSX sur plusieurs écrans et de pouvoir interfacer le programme avec l'ensemble des
éléments du cockpit, nous avons du choisir le nombre de machines ainsi que leur configuration.
Dans un premier temps nous nous sommes occupé de choisir le nombre de machines à acheter, et donc pour cela
le nombre d'écrans à interfacer en tout et pour tout. Sachant qu'il avait été décidé de ne faire que la partie
pilote du cokcpit et de délaisser la partie copilote, seulement une partie des instruments de bords avaient besoin
de disposer d'un moniteur capable de faire l'affichage. L'ensemble des écrans étant utilisés pour l'affichage des
instruments de bords est au nombre de deux. Pour l'affichage du monde exterrieur, il a été choisi d'utiliser un
ensemble de 4 écrans 24 pouces. Cela nous amène donc à interfacer 6 écrans au total.

Nous avons décidé d'utiliser des machines d'une puissance assez importante en raison de la taille des écrans utilisés. De
plus, afin de limiter le coût des machines, nous avons fait le choix de n'utiliser qu'une seule carte graphique par
ordinateur, les configurations multicarte ayant un prix nettement plius important pour des performances d'affichage
qui peuvent baisser si on installe trop d'écrans sur chaque PC.

Dans un deuxième temps il a fallu choisir le type de boitier a adopter. Le principal argument ayant orienté notre
choix réside dans l'espace requis pour les boitiers. En effet, une des priorités était de pouvoir déplacer le cockpit
pour faire des démonstrations, et dans ce cas de figure l'utilisation de PC en rack se trouvait beaucoup plus
intéressante que l'utilisation d'un boitier classique. Pour déplacer les ordinateurs cette configuration à beaucoup
plus d'avantage que pour une tour classique. De plus ceci permettra de mettre dans le rack le switch que nous
utilisons pour faire communiquer les pc entre eux.

Afin de pouvoir supporter facilement la charge de travail imposée par flight simulator et ses programmes annexes,
avons décider de configurer une machine avec un processeur quatre coeur, ainsi que deux autres machines avec
des processeurs double coeur s'occupant des affichages du monde exterrieur et des instruments de bords.

\section{Organisation}
Pour développer notre cockpit, nous avons établi des blocs fonctionnel, en fonction des fonction à réaliser. Ce découpage est réalisé selon la figure \ref{fig:schema_bloc}.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.7]{images/schema_bloc}
  }
  \caption{Schéma bloc}
  \label{fig:schema_bloc}
\end{figure}



Pour nous répartir le travail à réaliser, nous avons créé plusieurs sous-groupes au sein du projet. Chacun d'eux avait la responsabilité de développer une partie. Celles-ci correspondaient à une fonctionnalité de l'avion. Nous avons réalisé ce partage selon un découpage "horizontal", tel que montré sur la figure \ref{fig:decoup_horizontal}.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.7]{images/decoup_horizontal}
  }
  \caption{Découpage horizontal du projet}
  \label{fig:decoup_horizontal}
\end{figure}

Par la suite, nous avons abandonné ce système. Il ne permettait pas de réaliser des blocs fonctionnels réutilisables comme nous le souhaitions. En effet, ce système aurait nécessité que chaque sous-groupe développent sont interface avec le bus CAN par exemple. Il en est de meme pour plusieurs éléments. Pour cela, nous avons réalisé un nouveau découpage. Celui-ci sépare les tâches selon leur nature. Il permet de regrouper des fonctions identique entre elles. Ainsi chaque groupe est devenu responsable d'une fonction électronique au lieu d'une fonctionnalité de l'avion. Cette méthode nous a permis de développer des blocs génériques comme nous le souhaitions. Cette architecture permet de gagner en modularité. Elle facilite l'ajout de nouveaux éléments. Ce découpage est de type "vertical", il est détaillé sur la figure  \ref{fig:decoup_vertical}.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.7]{images/decoup_vertical}
  }
  \caption{Découpage vertical du projet}
  \label{fig:decoup_vertical}
\end{figure}
