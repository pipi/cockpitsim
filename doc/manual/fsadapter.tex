\chapter{FSAdapter: Interface avec Microsoft Flight Simulator X (FSUIPC)}
\authors{
  \authorinfo{Julien}{Peeters} \\
  \authorinfo{Alexandra}{Starynkevitch} \\
  \authorinfo{Zhibin}{Yin}
}

\section{Description et contexte}
L'objectif de cette partie du projet est de créer un lien entre le simulateur physique
et le simulateur logiciel. Pour cela, nous disposions déjà  d'un accès aux données
du modèle aéronautique via FSUIPC \footnote{Logiciel développé par Peter Dowson
(\url{http://www.schiratti.com/dowson.html}) permettant d'accéder aux données du
modèle sous la forme d'un tableau index.}.

Lors des débats technologiques initiaux, le choix s'est porté vers le protocole CAN pour gérer l'échange de données
entre la partie physique et la partie logicielle. Outre la gestion des données via FSUIPC,
notre logiciel, FSAdapter, a également la fonction de gérer les messages qui transitent sur
le bus CAN, en réception ainsi qu'en émission.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/archi_fsadapter}
  }
  \caption{Architecture dans laquelle se trouve FSAdapter}
  \label{fig:archi_fsadapter}
\end{figure}

Sur base de cette architecture, illustrée en figure \ref{fig:archi_fsadapter}, nous avons du mettre
en place les points suivants :

\begin{enumerate}
  \item Offrir un accès facile et sûr aux données du modèle aéronautique via FSUIPC.
  \item Ajouter une gestion des messages transitant sur le bus, ce qui inclut la mise à 
   jour des données du modèle lors de la réception d'un message depuis le simulateur
  physique et l'émission d'un message vers ce dernier lors de la détection d'un 
  changement dans le modèle.
\end{enumerate}

\section{Définitions des besoins}
\subsection{Contraintes contextuelles}
Lors de l'étude initiale de cette partie du projet, il avait été fait le choix de l'écrire
en C++ dû au fait que FSUIPC est fortement polymorphe \footnote{FSUIPC contient des données
de types forts différents et par conséquent les données du modèle sont représentées de manière
relativement hétérogènes sur l'ensemble du tableau.}. Par la suite, et sur les conseils de
notre tuteur, nous sommes passés à une solution en C. Cependant, nous nous sommes rapidement aperçus
que cette solution engendrerait beaucoup de possibilités d'erreurs et de bogues pour des
raisons que nous n'aborderons pas ici. Il a donc été fait le choix de revenir à la solution initiale,
à savoir écrire notre logiciel en C++.

Pour cela, Julien Peeters a été affecté en renfort à l'équipe initiale, composée au départ d'Alexandra 
Starynkevitch et de Zhibin Yin.

En dehors du choix du langage de programmation qui allait déterminer l'orientation majeure de cette
partie du projet, une contrainte importante a été mise en évidence: le grand nombre des données
du modèle accessibles au travers de FSUIPC.
 
\subsection{Cahier des charges du logiciel}
Comme nous l'avons précisé précédemment, l'objectif de cette partie est de relier Microsoft Flight Simulator X à notre 
cockpit - la partie physique de notre simulateur. 
Plus précisément, nous voulions créer une variable pour chaque capteur ou actionneur du simulateur (par exemple, 
une variable pour un interrupteur). Cetter dernière serait alors reliée aux données disponibles via FSUIPC par l'intermédiaire du 
logiciel que nous avons créé: FSAdapter. 
Une fois toutes les variables créées, il fallait définir les trames à envoyer à travers le bus CAN. Pour simplifier l'utilisation 
de ce dernier et donc des messages qui y sont envoyés, les trames doivent être préalablement définies. Pour se faire,
ces variables vont être regroupées par familles de manière à créer des trames ne dépassant pas 8 octets - contrainte imposée par le 
protocole CAN. 

Une famille est un regroupement de plusieurs données correspondant à des capteurs et des actionneurs faisant appel à un même type de matériel. Par exemple, les commandes du pilote automatique situées sur le \emph{Front-Panel} - ou \emph{FCU} \footnote{Pour rappel, le
FCU est l'acronyme anglais de Flight Control Unit, qui contient, entre autres, les commandes du pilote automatique.} constitueront une seule famille.

Pour différencier ces familles, on utilise directement l'identifiant du message CAN que nous utilisons de la manière 
suivante: lorsque le message va de FSAdapter vers les modules CAN, les trois derniers bits de poids le plus faibles de l'identifiant 
sont à 0. Dans le sens inverse, des modules CAN vers FSAdapter, les trois derniers bits permettent de déterminer quel paramètre de la trame qui correspond à la donnée qui a été modifiée. Les autres bits de l'identifiant permettent de différencier les familles entre
elles.

\section{Description du logiciel}
Afin que notre logiciel puisse complètement s'interfacer avec FSUIPC, il a fallu écrire le programme de manière à pouvoir écrire et 
lire les données provenant de ce dernier. Notre logiciel se découpe dès lors en 2 sous-parties, le mode lecture et le mode écriture vers FSUIPC.

\subsection{Mode écriture}

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.4]{images/write}
  }
  \caption{Écriture des messages vers FSUIPC}
  \label{fig:write}
\end{figure}

Cette partie du programme lit les messages provenant du bus CAN et après traitement de celles-ci, met à jour les données sur FSUIPC.
Une structure \textit{from-can} construite sous forme d'un tableau à double entrée contenant des fonctions de traitement des données 
reçues et rassemblant toutes les trames circulant à travers le bus CAN. Chaque ligne de ce tableau est exactement une trame dont 
l'indice est les 8 bits de poids fort de l'identifiant. Les 3 bits de poids faible permettent de connaître la variable dans une 
trame donnée qui a été modifiée. Le logiciel récupère les données provenant du bus CAN et commence par lire l'identifiant ce qui 
permet de retrouver l'emplacement de la donnée dans la structure \textit{from-can}. Cela fait ainsi appel à une fonction de traitement. 
Ces fonctions de traitement ne sont pas unique pour chaque donnée reçue. Elles sont écrites pour une famille de donnée. Ces fonctions 
prennent les données reçues par le bus CAN en paramètre et donnent 
en sortie les valeurs à écrire sur FSUIPC.

\subsection{Mode lecture}

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.4]{images/Read}
  }
  \caption{Lecture des messages depuis FSUIPC}
  \label{fig:Read}
\end{figure}

Le mode lecture est l'inverse du mode écriture. Le programme lit les données provenant des FSUIPC et après traitement des données, il 
envoie les valeurs modifiées à travers le bus CAN. Les données provenant de FSUIPC sont stockées dans une structure \textit{to-can} 
de même type que la structure \textit{from-can}. La table \textit{to-can} est mise à jour tous les 50ms. Lorsqu'une valeur est 
modifiée, une fonction de traitement est appelée. Cette fonction prend la valeur provenant de FSUIPC et calcule la donnée à 
envoyer à travers le bus CAN. Dès qu'une donnée a été modifiée, la trame correspondante est envoyée à travers le bus CAN.

\section{Évolution du programme} 
Dans un premier temps, étant donné que nous ne connaissions pas toutes les variables que nous seront amenés à utiliser dans FSUIPC, 
nous avons décidé de créer un logiciel pouvant ajouter n'importe quelle valeur provenant de ce dernier, sans modifier directement le 
programme. Cet atout majeur permis de créer de petites évolutions très simplement, en rajoutant une variable par exemple. 

Les données provenant de FSUIPC et les informations les concernant étaient sauvegardées dans un fichier texte pouvant être lu par le 
programme. Les données qui étaient utilisées par le simulateur étaient intégrées dans une structure de type table de Hash. De ce fait, 
lorsqu'une nouvelle valeur de FSUIPC était utilisée, elle s'intégrait automatiquement dans la table. Celle-ci devait être mise à jour à 
une certaine période et envoyée vers le simulateur. 

La complexité de ce programme résidait dans le fait que toutes les données devaient être reliées à un point précis de notre simulateur. 
Cela impliquait de connaître le détail de toutes les valeurs provenant de FSUIPC et le détail de toutes les fonctionnalités des
commandes du simulateur. Étant donné que cette partie du programme demandait un temps considérable, notre tuteur nous a alors conseillé 
de changer notre approche du logiciel. Nous nous sommes donc concentré sur la création d'une ou deux familles pour commencer.

Par la suite, face au retard que nous avions accumuler et à la complexité magré tout persistante, nous avons dû revoir nos choix, en
particulier sur la solution à envisager au niveau de la programmation. Comme cela l'a été dit précédemment, nous sommes reparti de la 
solution initiale en C++. Une fois cette le développement abouti, nous avons pu faire fonctionner notre logiciel comme interface avec 
FSUIPC conformément à nos espérences.
