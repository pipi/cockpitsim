\chapter{FSAdapter: Interface avec Microsoft Flight Simulator X (FSUIPC)}
\authors{
  \authorinfo{Julien}{Peeters} \\
  \authorinfo{Alexandra}{Starynkevitch} \\
  \authorinfo{Zhibin}{Yin}
}

\section{Description et contexte}
L'objectif de cette partie du projet est de créer un lien entre le simulateur physique
et le simulateur logiciel. Pour cela, nous disposions déjà d'un accès aux données
du modèle aéronautique via FSUIPC \footnote{Logiciel développé par Peter Dowson
(\url{http://www.schiratti.com/dowson.html}) permettant d'accéder aux données du
modèle sous la forme d'un tableau indexé.}.

Lors des débats technologiques initiaux, le choix s'est porté vers le protocole CAN
\footnote{Acronyme de \textit{Controller Area Network}.} pour gérer l'échange de données
entre la partie physique et la partie logicielle. Outre la gestion des données via FSUIPC,
notre logiciel, FSAdapter, a également la charge de gérer les messages qui transitent sur
le bus CAN, en réception ainsi qu'en émission.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/archi_fsadapter}
  }
  \caption{Architecture de FSAdapter}
  \label{fig:archi_fsadapter}
\end{figure}

Sur base de cette architecture, illustrée en figure \ref{fig:archi_fsadapter}, nous devions mettre
en place les points suivants :
\begin{enumerate}
  \item Offrir un accès facile et sûr aux données du modèle aéronautique via FSUIPC.
  \item Ajouter une gestion des messages transitant sur le bus, ce qui inclu la mise
  à jour des données du modèle lors de la réception d'un message depuis le simulateur
  physique et l'émission d'un message vers ce dernier lors de la détection d'un 
  changement dans le modèle.
\end{enumerate}

\section{Définitions des besoins}
\subsection{Contraintes contextuelles}
Lors de l'étude initiale sur cette partie du projet, il avait été fait le choix de l'écrire
en C++ du au fait que FSUIPC est fortement polymorphe \footnote{FSUIPC contient des données
de types forts différents et par conséquent les données du modèle sont représentées de manières
relativement hétérogènes sur l'ensemble du tableau.}. Par la suite, et sur les conseils de
notre tuteur, nous sommes passé à une solution en C. Cependant, nous nous sommes rapidement aperçus
que cette solution engendrerait beaucoup de possibilités d'erreurs et de bogues pour des
raisons que nous n'aborderons pas ici. Il a donc été fait le choix de revenir à la solution initiale,
à savoir écrire notre logiciel en C++.

Pour cela, Julien Peeters a été affecté en renfort à l'équipe initiale, composée au départ d'Alexandra 
Starynkevitch et de Zhibin Yin.

En dehors du choix du langage de programmation qui allait déterminer l'orientation majeure ce cette
partie du projet, une contrainte importante a été mise en évidence: le grand nombre des données
du modèle accessibles au travers de FSUIPC.
