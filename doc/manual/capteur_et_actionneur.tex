\chapter{Capteur et actionneur}
\authors{
  \authorinfo{Romain}{Marchaudon} \\
  \authorinfo{Johnny}{Phor}
}


\section{Commutateur et afficheur}
\subsection{Description et contexte}

Bloc Front Panel
Utilisation de circuits directement ineffaçables I2C : PCF 8575
Dans le cadre du projet il a étdemandde réaliser plusieurs parties distinctes du cockpit. Une de ces parties
correspond au front panel, et plus précisément la partie MCP ajoutau contrôle des trains d'atterrissages de
l'avion. Il existait deux solutions que nous avons prises en compte pour gérer les actions provenant de l'appui
sur ces boutons :
\begin{itemize}
  \item L'utilisation du FPGA
  \item L'utilisation du PCF8575.
\end{itemize}
C'est cette dernière solution qui a étretenue. En effet elle présentait l'avantage d'être la fois rapide 
mettre en oeuvre et de plus les circuits PCF8575 sont directement compatible I2C. De plus la solution FPGA,
même si elle permettait de limiter le nombre de circuits utiliser dans le cockpit, augmentait la charge
du FPGA et aller certainement faire perdre du temps dans sa mise en place en raisons des tests que nous
aurions du effectuer dessus.

Pour finir, lors du développement du code I2C sur les contrôleurs BECK, les circuits PCF8575 que nous avions notre disposition ont servit éprouver le fonctionnement du code implantsur les BECK. De cette manière il était déjsur que ces circuits fonctionneraient parfaitement avec l'ensemble de la chaine de traitement implantée dans le cockpit.

Le MCP du cockpit n'ayant jamais éten notre possession temps, nous avons du faire avec les informations
disponibles pour connaitre le nombre de boutons, diodes, commutateurs position et encodeurs incrémentaux 
interfacer. Pour faciliter les choses, nous avons choisi de regrouper sur les circuits PCF les boutons poussoirs
entre eux, les diodes également et de la même manière les commutateurs positions. De cette manière nous utilisons
actuellement 6 circuits PCF pour l'ensemble de ce bloc. Ce dernier est composcomme ceci :
-	32 diodes implantées sur 2 PCF8575
-	25 boutons poussoirs pour 2 PCF8575
-	Nyanya commutateurs positions pour les deux derniers PCF8575 utilisés.
Cette disposition a étdécidée avec le groupe BECK afin de faciliter la lecture et l'écriture sur les PCF. 
En effet, de cette manière les PCF sont soit en lecture (boutons poussoirs et commutateurs positions) ou bien en écriture (diodes). Nous avons également décidde ne brancher que 32 diodes sur les 33 pour des facilités de 
routage et éviter d'utiliser un circuit supplémentaire pour une seule sortie sur les seize disponibles. De plus 
la présence de cette 33 ème diode n'a pu être éprouvée du fait que nous ne disposons pas des blocs sous les yeux.
en effet un doute persiste sur la présence ou non de cette diode qui aurait alors une lumière blanche 
(et non jaune) et dont l'utilitn'a pas étvraiment prouvée. De plus comme nous l'avons vu avec monsieur 
Bouaziz, l'interfaçage des boutons, diodes et commutateurs sur le FPGA serait une solution plus stable dans le
temps, et sera donc a priori la futur solution dans le cockpit. En effet, de cette manière,  tous les composants
seraient alors interrogés de la même manière, et plus besoin d'utiliser un nombre d'adresses limités avec les PCF,
ces derniers n'ont que 3 bits modifiables dans leur adresse ce qui limite le nombre de PCF 8 sur chaque bus I2C.
Néanmoins même dans ces conditions, le front panel et la console centrale peuvent voir leurs boutons, 
commutateurs et diodes interfacées sur les PCF8575.

Au niveau du fonctionnement des PCF, il a étdécidde brancher les diodes en pull-up. De cette manière, 
il faudra appliquer un niveau zéro sur le PCF pour allumer une diode. De leur côt pour les boutons 
poussoirs et les commutateurs positions, l'appui sur une touche ou le contact effectupour les commutateurs
correspondra un niveau logique 0. Nous relierons donc l'ensemble des commutateurs et boutons poussoirs ¨¤ la masse.

Au niveau des afficheurs,  c'est l'afficheur de 7 segments qui est adopt¨¦. Comme tous les affichages des param¨¨tres
d'avion ont les m¨ºmes fonctionnements. Donc ?a suffit de tester l'affichage pour un param¨¨tre. En prenant en compte 
qu'on a r¨¦ussi une cha?ne compl¨¨te pour l'altitude en cas d'autopilote. On a test¨¦ l'affichage d'altitude.

Une carte avec interface I2C ayant 4 afficheurs de 7 segments  est ¨¤ notre disposition. C'est SAA1064 qui est int¨¦gr¨¦ 
dans cette carte. SAA1064 a 2 bits modifiables dans leurs adresses ce qui limite le nombre des cartes ¨¤ 4 sur chaque 
bus I2C. ?a pose des  probl¨¨mes si on veut afficher tous les param¨¨tres. Mais comme il n y a pas d'autres afficheurs 
qui sont ¨¤ la disposition et pour simplifier le test. On n'a pas d'autres choix.  Mais l'avantage de SAA1064 est la 
possibilit¨¦ de changer l'intensit¨¦ d'affichage.

On a programm¨¦ un compteur de 0 ¨¤ 9999 pour tester l'affichage d'altitude. Elle a fonctionn¨¦ correctement.

Du cot¨¦ de BECK, il a ¨¦t¨¦ demand¨¦ de r¨¦aliser la d¨¦tection d'appui sur une touche ou du  changement de position de 
commutateurs ¨¤ position et aussi la actualisation d'affichage. Pour la premi¨¨re partie, c'est-¨¤-dire la d¨¦tection de 
changement des donn¨¦es de PCF. Il suffit de lire les donn¨¦es de PCF via bus I2C et les compar¨¦ avec les donn¨¦es 
anciennes. Si un changement est d¨¦tect¨¦, les donn¨¦es de PCF seront remplac¨¦es par ces nouveaux. Le BECK va envoyer un 
message CAN correspondant comportant  les nouveaux ¨¦tats de touche et les positions actuelles de commutateurs ¨¤ PC. 
Au niveau d'actualisation d'affichage. Chaque fois un message CAN visant ¨¤ modifier l'affichage arrive, le BECK le 
traiter et envoyer les donn¨¦es contenues dans le message CAN ¨¤ afficheur correspondant.

Etant donn¨¦ que la d¨¦tection d'appui sur une touche et changement de position de commutateurs dure beaucoup plus long 
que  actualisation d'affichage, un TIMER est utilis¨¦ pour que le message CAN re?u ne soit pas perdu en sachant que le 
pile de BECK ¨¤ enregistrer le message est limit¨¦. De plus, on peut s'assurer que l'actualisation d'affichage soit 
trait¨¦e ¨¤ temps. L'automate se repr¨¦sente en figure \ref{fig:Automate_PCF}

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/Automate_PCF}
  }
  \caption{Automate de PCF}
  \label{fig:Automate_PCF}
\end{figure}

Comme un appui sur une touche dure quelque 100 ms, donc un TIMER de 50 ms est raisonnable. Tout l'appui peut ¨ºtre 
d¨¦tect¨¦.  Pendant le test, on a utilis¨¦ un PCF dont 16 pattes sont connect¨¦ ¨¤ 1 r¨¦cessif. Puis on a connect¨¦ une 
patte ¨¤ la masse, c'est la m¨ºme que un appui sur une touche. Le PcCANView ¨¤ bien re?u un message CAN envoy¨¦ par le 
BECK. Pour tester l'actualisation d'affichage, on a utilis¨¦ le PcCANView pour envoyer un message CAN ¨¤ BECK, et puis 
on a constat¨¦ l'affichage de valeur contenue dans le message CAN envoy¨¦.

Au d¨¦but du test, on s'est tromp¨¦ de niveaux dominant. On a pens¨¦ ¨¤ 1 dominant dans le circuit. Mais il a apparu que 
c'est toujours 0 dominant. Donc il faut connecter le bouton ¨¤ la masse. L'autre probl¨¨me rencontr¨¦ est pour lire les 
pattes de PCF, il faut s'assurer que le registre de mode ¨¦criture est 0Xffff avant lecture. Pendant la programmation, 
on a eu un probl¨¨me d'utilisation de pointeur. Au d¨¦but, on n'a pas utilis¨¦ le pointeur comme param¨¨tre de fonction. 
Donc la nouvelle valeur ne remplace pas celle ancienne. Il a toujours indiqu¨¦ un changement.

\section{Encodeur incrémental}

\section{Clavier matriciel}

\section{Commande des gaz}
