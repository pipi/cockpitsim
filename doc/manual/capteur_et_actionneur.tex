\chapter{Capteurs et actionneurs}
\authors{
  \authorinfo{Romain}{Marchaudon} \\
  \authorinfo{Johnny}{Phor}\\
  \authorinfo{Salwa}{Bahji}\\
  \authorinfo{Alexandre}{Ouazan} \\
  \authorinfo{Chunlin}{Zhu}\\
  \authorinfo{Herilanja}{Ramanahadray}
  

}

\section{Commutateur et afficheur}
\subsection{Description et contexte}

\subsubsection{Bloc Front Panel : Utilisation de circuits directement ineffaçables I$^2$C : PCF 8575}

Dans le cadre du projet il a été demandé de réaliser plusieurs parties distinctes du cockpit. Une de ces parties
correspond au "front panel", et plus précisément la partie FCU ajoutée au contrôle des trains d'atterrissage de
l'avion. Le but ici était de pouvoir appuyer sur un bouton physique tout en ayant l'action voulue au sein de FSX.
Dans le même temps, les diodes indiquant l'état du bouton auquel elles sont attachées devait, lui, être commandé par
le logiciel Flight Simulator.

\subsubsection{Conception et choix techniques}
 Deux solutions ont été envisagées afin gérer les actions provenant de l'appui sur les boutons :
\begin{itemize}
  \item L'utilisation du FPGA
  \item L'utilisation du PCF8575.
\end{itemize}

C'est cette dernière solution qui a été retenue. En effet elle présente l'avantage d'être la fois rapide 
à mettre en oeuvre et de plus, les circuits PCF8575 sont directement compatible I$^2$C. De plus la solution FPGA,
même si elle permettait de limiter le nombre de circuits utilisé dans le cockpit, augmentait la charge
du FPGA et allait certainement faire perdre du temps dans sa mise en place en raison des tests que nous
aurions dû effectuer dessus.

Pour finir, lors du développement du code I$^2$C sur les contrôleurs BECK, les circuits PCF8575 que nous avions à 
notre disposition ont servit éprouver le fonctionnement du code implantsur les BECK. De cette manière il était
déjà sur que ces circuits fonctionneraient parfaitement avec l'ensemble de la chaine de traitement implantée dans le cockpit.

\subsubsection{Développement}
Le FCU du cockpit n'ayant pu être en notre possession à temps, nous avons dû nous contenter des informations
dont nous disposions pour connaitre le nombre de boutons, diodes, commutateurs à positions et encodeurs incrémentaux 
à interfacer. Pour faciliter les choses, nous avons choisi de regrouper sur les circuits PCF les boutons poussoirs
entre eux, les diodes ainsi que de la même manière les commutateurs à positions. De cette manière nous utilisons
actuellement 6 circuits PCF pour l'ensemble de ce bloc. Ce dernier est composé comme ceci :
\begin{itemize}
  \item 32 diodes implantées sur 2 PCF8575
  \item 25 boutons poussoirs pour 2 PCF8575
  \item 6 commutateurs à positions pour les deux derniers PCF8575 utilisés.
\end{itemize}





Cette disposition a été décidée avec le groupe de développement BECK afin de faciliter la lecture et l'écriture sur les PCF. 
En effet, de cette manière les PCF sont en lecture (boutons poussoirs et commutateurs à positions) ou bien en 
écriture (diodes). Nous avons également décidé de ne brancher que 32 diodes sur les 33 pour des facilités de 
routage et éviter d'utiliser un circuit supplémentaire pour une seule sortie sur les seize disponibles. De plus 
la présence de cette 33$^e$ diode n'a pu être éprouvée du fait que nous ne disposons pas du matériel sous les yeux.
De plus comme nous l'avons vu avec monsieur Bouaziz, l'interfaçage des boutons,
diodes et commutateurs sur le FPGA serait une solution plus stable dans le
temps, et serait donc à priori la future solution pour le cockpit. En effet, de cette manière,  tous les composants
seraient alors interrogés de la même manière. De plus une autre limite sur les PCF serait levée, à savoir la
limite du nombre de PCF par bus I$^2$C, ces derniers n'ayant que 3 bits modifiables
dans leur adresse, ce qui limite le nombre de PCF à 8 sur chaque bus I$^2$C.
Néanmoins, même dans ces conditions, le "front panel" et la console centrale ont leurs boutons, 
commutateurs et diodes interfacées sur les PCF8575.

Au niveau du fonctionnement des PCF, il a été décidé de brancher les diodes en pull-up. De cette manière, 
il faudra appliquer un niveau zéro sur le PCF pour allumer une diode. De leur côté, les boutons 
poussoirs et commutateurs à positions seront en position fermés quand un niveau 0 sera visualisé sur les PCF. Nous relierons
donc l'ensemble des commutateurs et boutons poussoirs à la masse.


\subsection{Afficheurs sept segments}
\subsubsection{Contexte et objectif}
Dans le FCU du cockpit, en plus des boutons et autres commutateurs on peut trouver plusieurs blocs d'afficheurs
sept segments servant à afficher plusieurs données importantes comme par exemple l'altitude. Ces informations
proviennent directement de FSX et il est donc important de pouvoir interfacer ces afficheurs avec l'ensemble de la
chaine d'acquisition des données. Il est ici encore question de respecter le fonctionnement des afficheurs et des éléments
qui leurs sont liés dans le cockpit, à savoir les encodeurs incrémentaux. En effet ce sont les encodeurs incrémentaux
qui s'occupent d'envoyer la valeur à afficher à FSX, et ce sont aussi eux qui valident la valeur par un appui
sur le bouton poussoir incorporé.

\subsubsection{Conception et choix techniques}
Comme expliqué plus haut,  nous avons adopté l'afficheur 7 segments pour les affichages dans le FCU.
Afin de valider ce bloc fonctionnel,
nous n'avons eu à afficher qu'une seule valeur puisque tous les afficheurs du cockpit fonctionnent de la même manière.
Il a donc suffit de tester l'affichage pour un paramètre. En prenant en compte 
qu'on disposait d'une chaine complète jusqu'a FSX pour l'affichage de l'altitude.

Une carte disposant d'une interface I$^2$C avec 4 afficheurs 7 segments était à notre disposition. C'est le
circuit SAA1064 qui est intégré sur cette carte et qui multiplexe pour les quatres afficheurs.
Le SAA1064 dispose de 2 bits modifiables dans leur adresse ce qui limite le nombre de circuits à 4 sur 
chaque bus I$^2$C. Cela pose des  problèmes si on veut afficher l'ensemble des paramètres du FCU.

Mais le SAA1064 présence l'avantage de disposer d'un réglage de l'intensité d'affichage.

Du coté du BECK, il a été demandé de réaliser la détection d'appui sur une touche ou du  changement de position de 
commutateurs à position et aussi la actualisation d'affichage. Pour la première partie, c'est à dire la détection de 
changement des données de PCF. Il suffit de lire les données de PCF via bus I$^2$C et les comparer avec les données 
anciennes qui sont enregistré dans un tableau. Si un changement est détecté, le tableau sera actualisé. Le BECK va 
envoyer un 
message CAN correspondant comportant  les nouveaux états de touche et les positions actuelles de commutateurs au PC. 
Au niveau d'actualisation d'affichage. Chaque fois un message CAN visant a modifier l'affichage arrive, le BECK le 
traite et envoie les données contenues dans le message CAN à l'afficheur correspondant.

Pour s'assurer que le bus CAN ne soit pas surchargé, un TIMER de 50 ms est utilisé. Seulement quand le TIMER-FLAG 
est mis à 1, le BECK envoie un message CAN si le changment de données est détecté.  Mais le BECK met à jour toujours 
l'affichage si un message CAN est reçu. Puisque la détection d'appui est fait toujours, donc tout appui peut être 
détecté. L'automate se représente en figure \ref{fig:Automate_PCF}. Au départ, le BECK cherche le message CAN dans 
la pile. Si un message est reçu, il fait mis à jour l'affichage. Par la suite, il décide s'il faut mettre à jour le 
tableau. Quand le TIMER-FLAG est mis à 1. Le BECK vérifie s'il y a un changement de données et remet TIMER-FLAG à 0.  
Si un changement de données est détecté, le BECK envoie un message CAN à PC et remet DataHasChanged (1 s'il y a un 
changement de données) à 0.

Mais le SAA1064 présente l'avantage de disposer d'un réglage d'intensité d'affichage.

\subsubsection{Développement}

Du coté du BECK, il a été demandé de réaliser la détection d'appui sur une touche et le changement de position des 
commutateurs à positions ainsi que l'actualisation de l'affichage. Pour la première partie, c'est à dire la détection du changement des données sur le PCF, il suffit de lire les données du PCF via le bus I$^2$C et de comparer avec les
anciennes valeurs qui ont été enregistrées dans un tableau. Si un changement est présent, le tableau sera
actualisé sur le BECK. Ce dernier envoie alors le 
message CAN correspondant comportant les nouveaux états des touches et commutateurs au PC. 
Pour l'actualisation de l'affichage, à chaque arrivée d'un message CAN, le BECK le 
traite et envoie les données reçues à l'afficheur correspondant.

Pour s'assurer que le bus CAN n'est pas surchargé, un TIMER de 50 ms est utilisé. Une fois que le TIMER-FLAG 
passe à 1, le BECK envoie un message CAN si un changement de données est détecté. Pour sa part, le BECK met toujours à jour
l'affichage dès qu'un message CAN est reçu. Tout appui sur une touche sera détecté puisque le code fonctionne en continu . L'automate est représenté en figure \ref{fig:Automate_PCF}. Au départ, le BECK cherche le message CAN dans 
la pile. Si un message est reçu, il fait la mise à jour de l'affichage. Ensuite, il décide s'il faut mettre à jour le 
tableau. Une fois que le TIMER-FLAG est mis à 1, le BECK vérifie s'il y a un changement de données et remet le TIMER-FLAG à 0.  
Si un changement de données est détecté, le BECK envoie un message CAN au PC et remet DataHasChanged à 0 (1 s'il y a un changement de données).


\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/Automate_PCF}
  }
  \caption{Automate de PCF}
  \label{fig:Automate_PCF}
\end{figure}


Pendant le test, nous avons utilisé un PCF dont 16 pattes sont connectées à un niveau 1 récessif. Nous avons connecté une patte à la masse, de la même manière que pour un appui sur une touche. Le PcCANView à bien reçu un message
CAN envoyé par le BECK. Pour tester l'actualisation de l'affichage, nous avons utilisé le PcCANView pour envoyer

\subsubsection{Résultats}

Pour le test, nous avons utilisé un PCF dont 16 pattes ont été connectées à un niveau 1 récessif, ainsi qu'une à la masse simulant l'appui sur une touche. Les tests ont été concluant!!!!!!!!!! Le PcanView à bien reçu le message
CAN envoyé par le BECK. Pour tester l'actualisation de l'affichage, nous avons utilisé le PcanView afin d'envoyer
un message CAN au BECK, la valeur affichée correspondant alors bien à la valeur contenue dans le message CAN.

Au début du test, nous nous sommes trompé de niveau dominant. Nous avions pensé à mettre un niveau 1 dominant dans le 
circuit, mais il nous ait apparu que c'était encore un niveau 0 dominant.
Il faut donc bien connecter les boutons à la masse. L'autre problème rencontré est pour la lecture des 
pattes du PCF, il faut s'assurer que le registre de mode écriture est 0Xffff avant d'effectuer une lecture.
Pendant la programmation, nous avons rencontrer des problèmes d'utilisation de pointeur de fonction.
En effet, au début, nous n'avions pas utilisé le pointeur comme paramètre des fonctions. 
Dans ce cas les modifications étaient perdues et on gardait toujours l'anciène valeur.
Après modification ceci fonctionait parfaitement.

\section{Encodeur incrémental}


\subsection{Contexte et objectif}

Les différents encodeurs numériques du cockpit ont diverses utilités comme la variation de la vitesse, la variation 
de l'altitude etc. Les valeurs récupérées de ces encodeurs sont différentes séquences de deux bits, ces séquences 
mises dans un certain ordre nous permettent d'identifier le sens de rotation des encodeurs.

L'objectif de ce bloc est d'interfacer ces séquences pour que le message envoyé au BECK soit compréhensible.

Les encodeurs étant reliés au FPGA, ils envoient leur trame aux FPGA, et celui-ci les analyse de la façon suivante :

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/automate_codeur}
  }
  \caption{Diagramme d'état de l'automate codeur }
  \label{fig:automate_codeur}
\end{figure}


Le schéma ci-dessus représente un bloc codé du FPGA : Le bloc automate codeur. Il a fallu prévoir un autre bloc 
comprenant un registre à implémenter en fonction du sens de rotation pour avoir une réelle appréciation de 
l'incrémentation ou de la décrémentation: Le bloc lpm-counter16. Chaque changement d'état de l'automate codeur 
fournit une impulsion au compteur qui lui indique qu'il doit incrémenter ou décrémenter selon le sens de rotation.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.3]{images/bloc_codeur_compteur}
  }
  \caption{Bloc codeur compteur }
  \label{fig:bloc_codeur_compteur}
\end{figure}


Le principe est alors que l'on envoi l'image de ce registre au beck quand il en fait la demande par le biais du bus 
I$^2$C.

\subsection{Conception et choix techniques}

La première solution envisagée était d'avoir des registres qui reflétaient exactement la valeur concernée (altitude, 
vitesse, etc.). Le beck  initialisait les registres au démarrage du cockpit puis la valeur était incrémentée ou 
décrémentée dans le FPGA de façon à correspondre à la valeur significative c'est-à-dire avec des coefficients 
multiplicateur associé à l'incrémentation/décrémentation. De cette façon, il n'y a aucun traitement à faire par les 
autres composantes de la chaines de commande : du FPGA jusqu'à FSUIPC.

Cette solution est plus contraignante au niveau du code à fournir et il semble que le FPGA ne doit pas servir au 
traitement pur et dur du calcul, ceci doit être fait par une composante plus performante de la chaine de commande.

La solution retenue est donc d'envoyer le registre correspondant à la valeur significative quand on le demande.
Celui-ci est incrémenter/décrémenter un à un et sa valeur est initialisée à 0. Avec cette solution, les blocs
fonctionnels sont plus simples, ils ne nécessitent pas l'écriture de la part du beck et le coté traitement de
l'information y ait simplifié. Pour ce qui est de l'envoie de la valeur, le beck fait une demande de lecture sur 
autant de registres qu'il y a d'encodeurs, le FPGA envoi les valeurs sur le bus I$^2$C registre après registre. 

\subsection{Développement}

	
Le protocole pour tester les encodeurs incrémentaux a été facilité de par le fait que nos cartes FPGA sont dotées 
d'un registre de LED et de quatre boutons poussoirs. Nous avons affecté deux boutons pour simuler l'encodeur et le 
registre sortant du compteur (lpm-counter16) a été affecté aux LED. Dans un deuxième temps, nous avons utilisé un 
encodeur incrémental mis à notre disposition. Ces deux manipulations ont été probantes du  bon fonctionnement 
automate-codeur associé au lpm-counter16. 


De la part du BECK, Nous avons seulement lu les registres pour obtenir les valeurs actuelles de l'encodeur. A chaque
fois, il enregistre la valeur obtenue. Une fois la valeur suivante lu, il calcul la différence entre les deux et 
obtient une valeur incrémentée/décrémentée qui signifie le changement de l'encodeur. On l'a testé avec les fonctions 
créées, quand on a incrémenté/décrémenté l'encodeur, nous avons réussi à afficher les valeurs correspondantes.

Les erreurs résiduelles concernaient notre automate I$^2$C slave.  


\subsection{Résultat}

Le résultat obtenu est des registres pour chaque valeurs significatives, que nous sommes capables d'envoyer par le 
biais du bus I$^2$C au beck, afin qu'ils soient traités. Sur le BECK, nous sommes capables de détecter le changement 
de l'encodeur, et d'envoyer ce changement par bus CAN vers le PC.

\section{Clavier matriciel}

\subsection{Contexte et objectif}

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.3]{images/matrice_clavier}
  }
  \caption{représentation du clavier matriciel}
  \label{fig:matrice_clavier}
\end{figure}

Le but de ce bloc est d'interfacer un clavier matriciel tel que celui décrit sur la figure suivante afin que le 
maître du bus I$^2$C puisse reconnaître quelle touche est actionnée. Le clavier matriciel a autant de colonnes et de lignes à relier pour en déduire l'information utile (appui ou non d'un bouton poussoir). Dans notre cas, cela 
implique 8 colonnes et 9 lignes. Le FPGA étant un processeur bénéficiant d'un nombre d'entrée/sorties important, il est une interface adéquate pour un clavier (9+8=17 entrées/sorties). Du côté de BECK, il a été demandé de réaliser la détection de touche, et également le décodage de cet appui.

La matrice ainsi câblée, autorise des niveaux 1 récessifs par défaut, c'est-à-dire sans action directe du FPGA. Chaque 
ligne et chaque colonne sont reliées bidirectionnellement au FPGA.

\subsection{Conception et choix techniques}


Dans un premier temps, nous avons envisagé que le FPGA traite les informations lui-même en mettant en place le
protocole de détection de touche. Une requête de lecture du clavier étant détectée, le FPGA renvoie la valeur 
associée de la dernière touche appuyée (de 1 à 72). Si cette valeur a déjà été envoyée et que l'on détecte une 
nouvelle requête de lecture de la part du beck, le FPGA renvoie la valeur 0. 

Cette solution implique une certaine simplicité du traitement sur le reste de la chaîne de commande, en contrepartie, 
elle demande un algorithme trop important à mettre en place au sein du FPGA. 
	 
La solution retenue au sein du FPGA est d'autoriser en lecture et en écriture les lignes et les colonnes de notre 
matrice. Le traitement direct de détection de touche se fait alors sur le maître du bus I$^2$C, c'est-à-dire le BECK. Dans ce cas, toutes les informations 
sont traitées par le BECK au lieu du FPGA.  
Il présente l'avantage d'être plus efficace, et il simplifie le fonctionnement du FPGA. Nous avons gardé les tailles 
génériques des registres utilisés auparavant. Les lignes sont codées sur 2 octets c'est-à-dire sur 2 registres, de 
même pour les colonnes. Certains bits correspondants aux lignes (8 bits) et aux colonnes (7 bits) ne sont pas reliés 
physiquement, toutefois, cela n'affecte en rien le traitement de l'information.


Les registres de lecture et d'écriture sont illustrés sur la figure\ref{fig:SI2C_blink}. Un registre d'écriture (à droite) correspond à un registre de lecture (à gauche) dans le cas du clavier matriciel.

\subsection{Développement}

Pour y arriver, au sein du BECK, nous avons créé les fonctions de façon à détecter s'il y a une touche appuyée ou pas, et 
ensuite en cas d'un appui, le décoder. Notre automate est illustré dans la figure \ref{fig:diagramme_etat_clavier}.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/diagramme_etat_clavier}
  }
  \caption{diagramme d'état du protocole de détection de touche }
  \label{fig:diagramme_etat_clavier}
\end{figure}

Pour réaliser la détection, sachant que les lignes et les colonnes sont codées sur 4 octets (4 registres), chaque écriture et chaque lecture sont faites sur 4 octets. Dans notre cas, les registres 1 et 2 de FPGA 
correspondent aux lignes, les registres 3 et 4 correspondent aux colonnes. Pour lire les données des registres du 
FPGA et également écrire sur les registres, on doit tout d'abord envoyer une trame contenant l'adresse de ces 
registres. En lisant les registres, on peut savoir s'il y a un appui effectué et obtenir un code brut. En cas de deux 
appuis détectés, nous considérons que c'est une erreur.

On distingue la différence entre le code touche (code brut) et la valeur de la touche qui représente la signification 
qu'on donne à la touche. Par la suite,nous avons besoin de décoder cette touche pour obtenir un code significatif.


A partir des principes ci-dessus, nous avons créé des fonctions pour détecter et décoder le clavier. Afin de les 
tester, nous avons réalisé un clavier matriciel de 3 colonnes et 3 lignes, illustré sur la figure 
\ref{fig:maquette_clavier}. A chacune des 9 touches correspond un bouton qui réalise un contact entre une ligne et 
une colonne. Les lignes et les colonnes sont polarisées à Vcc via des résistances de Pull-up, et sont connectées aux 
ports de FPGA.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/maquette_clavier}
  }
  \caption{maquette de test du clavier matriciel}
  \label{fig:maquette_clavier}
\end{figure}

Avec cette structure de clavier, nous sommes obligés de réaliser une lecture de la touche enfoncée en détectant 
d'abord la colonne, puis la ligne (ou inversement). En considérant l'existence de Pull-up, si nous voulons détecter 
la colonne, il faut fixer les lignes au niveau 0, c'est-à-dire écrire 0 sur les registres 1 et 2 (ligne), 1 sur 
les registres 3 et 4 (colonne), donc les colonnes présentent alors un niveau 1. En cas d'un appui de la touche, une 
colonne va passer au niveau 0, on obtient un code brut des colonnes. De la même façon, on procède au retournement du 
sens en fixant les lignes au niveau 1 et nous écrivons sur les colonnes les niveaux logiques qu'on vient d'obtenir. 
Dans ce cas, on peut obtenir un code brut des lignes. Niveau 0 présenté dans les codes correspond un appui, on peut 
donc décoder cet appui par localisation des 0.

Les tests que nous avons effectué nous ont permis de détecter l'appui d'une touche et de décoder la valeur significative correspondante à cette touche. A noter que les pins non connectée sur le FPGA prennent une valeur aléatoire. Pour remedier à ce probleme, nous avons ajouté des résistances de Pull-up sur la définition même des pins à l'intérieur du FPGA. Pour assurer la stabilité du signal, l'écriture par le beck des registres lignes et colonnes affecte des niveaux 0 à tous les bits n'ayant pas d'utilité significative. 

\section{Commande des gaz}
\subsection{Description et contexte}

	Pour la commande des gaz on veut être capable de contrôler les moteurs et le trim. On souhaite avoir accès aux commandes en position et en détection de dépassement de couple.

	Nous souhaitons être capables d'envoyer, d'une part, vers FSUIPC les différentes positions des servomoteurs et dans le sens FSUIPC vers les AX12, autrement dit le mode pilote automatique, les servomoteurs doivent être capables de se positionner à des angles bien précis. 
Pour cela on doit interfacer les servomoteurs avec le bus CAN. On doit donc adapter les formats de trames, venant des servomoteurs ou venant du bus CAN, afin que ces deux entités puissent communiquer entre elles.

Pour la réalisation des commandes de gaz nous utiliserons des Servomoteur Dynamixel AX12. Les AX12 sont pilotés par une liaison série et peuvent être reliés l'un à l'autre pour créer une chaîne de servomoteurs .Nos 3 servomoteurs peuvent donc cohabiter sur un même bus.
Ces moteurs ont une résolution de 1024 pas en position et une vitesse de rotation réglable également sur 1024 pas. En lecture, il est possible de connaître, entre autres, leur position courante et leur couple ce qui correspond bien à nos besoins.

\subsection{Conception fonctionnelle}
\subsubsection{Description architecturale}

D'après la description des besoins pour les commandes de gaz et le trim énoncées précédemment, notre réflexion sur la conception des commandes a abouti à la description architecturale représentée sur la figure \ref{fig:architecture fonctionnelle pour la commande des gaz}

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/archi2}
  }
  \caption{architecture fonctionnelle pour la commande des gaz}
  \label{fig:architecture fonctionnelle pour la commande des gaz}
\end{figure}

Au vu de cette architecture, on peut distinguer deux parties dans l'interfaçage du bus Can avec les servomoteurs :
\begin{itemize}

  \item Le stockage des données 
  \item Les modules de traitement des données
  
\end{itemize}

\textbf{Le stockage des données:}

On doit être capable de pouvoir s'adapter en fonction des besoins en informations du FSUIPC et du débit du bus CAN. Aussi, afin d'avoir les mises à jour les plus récentes des positions des servomoteurs, nous avons pensé à stocker les positions des servomoteurs. Les positions de chaque servomoteur seront récupérées très fréquemment et les données les plus récentes seront déjà présentes dans la table au moment voulu.
De plus, afin de ne pas surcharger le bus CAN et d'alléger les informations à destination de FSUIPC, une autre table (DATA CAN) serait souhaitable pour contenir toutes les mises à jour détectées dans la table.
Cependant, pour ce faire, des modules de récupérations, de traitement et d'envoi de données seront nécessaires.
D'où l'existence de l'autre partie de l'architecture.

\textbf{Les modules de traitement des données:}

Cette partie doit comprendre plusieurs modules et dépend du sens de parcours des données : soit des servomoteurs vers le bus (en pilotage manuel), soit du bus CAN(FSUIPC) vers les servomoteurs (en pilotage automatique). Ces modules doivent donc être capables d'acheminer les données en format adapté  de la manière la plus fiable et la plus rapide possible afin d'obtenir des réactions des plus réalistes.
Ainsi, des servomoteurs vers le bus CAN, ces modules doivent comprendre :

\begin{itemize}
  \item Un module d'acquisition et de stockage des positions des servomoteurs \textbf{fill data ax12}  qui se chargera de récupérer assez fréquemment la position de chaque servomoteur. Ainsi, il doit être apte à :
  	\begin{itemize}
  	\item Envoyer les instructions nécessaires pour lire la position des servomoteurs 
  	\item Recevoir ces positions
  	\item Les stocker dans la table
	\end{itemize}

\item Un module qui sert à détecter chaque mise à jour de la table  \textbf{detect table update}. Ce module doit être capable de détecter si les servomoteurs ont changé de position, auquel cas elle transfère ces mises à jours dans la table DATA-CAN qui contient les valeurs les plus récentes et prêtes à être envoyées à FSUIPC. 
  
  Ces deux modules, puisqu'ils gèrent des tables de données doivent être capables de gérer également le dépassement de la taille de ces tables, de les mettre à jour.
  
  \item Un module de conversion des positions des servomoteurs en puissance \textbf{convert angle to power}. Celle-ci préparera les données à envoyer à FSUIPC via le bus CAN, données qui doivent directement être compréhensibles par FSUIPC. 
  
  \item Un module qui créera le message CAN à envoyer \textbf{create CAN msg}. Ce module mettra en format adapté au bus CAN les valeurs des positions convertis en puissance et les enverra sur le bus.
  
\end{itemize}
Dans l'autre sens (du bus CAN vers les servomoteurs) les modules feront les opérations inverses. Ainsi, elles vont comprendre :
\begin{itemize}
  	\item Un module qui reçoit les messages véhiculés sur le bus CAN qui sont destinés aux commandes des gaz \textbf{decode CAN msg}. Elle est également sensée décoder le message : savoir à quel servomoteur il est destiné, récupérer ses paramètres (valeurs de puissances à mettre) et pouvoir les fournir.
  	\item Un module qui convertit les valeurs de puissances en angles directement interprétable par les servomoteurs \textbf{convert power to angle}. Il préparera les données qui doivent être envoyés aux servomoteurs et les met en forme pour être contenu à l'intérieur des plages de positions.
  	\item Un module qui crée les trames à envoyer aux servomoteurs \textbf{create ax12 frames}. Il doit recevoir l'angle converti et le numéro identifiant du servomoteur concerné. Il fournit une trame qu'on peut directement communiquer aux servomoteurs.
  	\item Un module qui envoie les trames déjà constitué \textbf{send ax12 frames}. Il doit envoyer successivement chaque octet de la trame suivant un ordre bien précis défini dans la documentation des servomoteurs.
  	\end{itemize}
  	
 Ces modules ainsi développés, il est nécessaire d'ordonner leur interaction afin d'obtenir des informations non-erronées, mis à jour et véhiculées le plus rapidement possible le tout d'une manière automatique. 
 
\subsubsection{Description fonctionnelle de l'automate}
 
La manière dont vont s'interagir les différents modules est gérée par un automate scindé en deux parties : pilote automatique et pilote manuel, voir figure \ref{fig:automate Commande des Gaz et Trim}
\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.4]{images/auto-ax12}
  }
  \caption{automate Commande des Gaz et Trim}
  \label{fig:automate Commande des Gaz et Trim}
\end{figure}

Néanmoins, ces deux parties sont fortement liées, parce que pour basculer de l'une à l'autre, il suffit d'enclencher ou de déclencher le pilotage automatique.
Chacune des deux parties fonctionne comme suit :

\begin{itemize}
  \item \textbf{Pilote automatique:}
Dans le cas du pilote automatique,  on commence par attendre la réception d'un message CAN. Une fois la réception achevée on décode le message de façon à ne garder que  les données utiles pour former les trames à envoyer aux servomoteurs. Cependant, les servomoteurs renvoient, à chaque fois qu'on communique avec, des trames de statut alors qu'on n'en a pas forcément besoin en pilote automatique. Voilà pourquoi nous devrons ajouter un autre état de latence afin d'éviter la réception de ces trames.

  \item \textbf{Pilote manuel:}
Dans le cas du pilotage manuel, on commence par interroger chaque servomoteur afin de connaitre à quelle position il se trouve. Puis on attend que le servomoteur en question réponde. Une fois la trame de statut complète reçue, on remplit la table qui va contenir les données venant du servomoteur concerné. Après on détecte les mises à jour éventuelles de la table et on les transfère vers la table DATA-CAN. La table DATA-CAN remplie, on crée les messages CAN contenant les nouvelles positions du servomoteur. Comme les états précédents ne concernent qu'un seul servomoteur, on passe à un autre servomoteur afin de lui appliquer les mêmes opérations. Si l'ID courant équivaut à celui du dernier servomoteur, on revient au premier.
\end{itemize}
 
\subsubsection{Carte d'interface}

Quand on étudie la documentation du Servomoteur Dynamixel, on remarque que ce dernier peut être contrôlé par un PC via un CM-5.
Le CM-5 possède un circuit interne qui permet de convertir les signaux en half-duplex. Le diagramme réalisant cette conversion est \ref{fig:half_duplex}:

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/half_duplex}
  }
  \caption{half-duplex}
  \label{fig:half_duplex}
\end{figure}

On souhaite donc, que les signaux, de niveaux TTL, RxD et TxD dépendent du signal Direction-Port.
Lorsque le signal Direction-Port est au niveau haut, le signal TxD est transmis vers DATA et lorsque, le signal Direction-Port est au niveau bas, le signal DATA est l'entrée du signal RxD.
On constate donc qu'on peut s'affranchir du CM5, d'une part à cause de son coût élevé et d'une autre part pour notre propre apprentissage, en réalisant une carte électrique qui produirait cette fonctionnalité du CM5.

Pour cela on pourra utiliser un GALisp22V10, qu'on implémentera via Abel.
D'autre part le GAL fonctionne avec des niveaux TTL alors que le port série fonctionne avec des niveaux logiques 1 et 0, notre carte d'interface devra également générer des niveaux TTL. Pour cela on pourra utiliser un MAX232, qui amplifie et met en forme deux entrées et deux sorties TTL/MOS vers deux entrées et deux sorties RS232. 
Cette carte nous permettra également d'obtenir le signal data nécessaire pour le servomoteur AX12 en sortie du circuit GALisp22V10, qui est également à un niveau TTL.

\subsection{Developpement et problèmes rencontrés}
Pour construire ces modules et ordonner leur interaction, afin de développer le gestionnaire des commandes de gaz, nous avons utilisé une carte BECK SC123 présentée précédemment. Les modules et la façon dont  on veut qu'ils interagissent entre eux ont été réalisés en langage C (langage utilisée par la carte Beck). De plus la carte est fournie avec des API déjà prédéfinis, contenus dans des librairies spécifiques et qu'on peut directement utiliser notamment pour la communication le port Série.
Les API qu'on a utilisé se trouvent dans la librairie "Clib.h" comme toutes les API du Beck et plus précisément dans "Fossil.h"(autre appellation de la communication Série).
\subsubsection{Développement des modules}

Pour créer les différents modules initialement énoncés, nous avons créé une libraire propre aux servomoteurs"ax12.c"(Cf Annexe ??) dans laquelle ces modules sont représentés par des fonctions qui prennent en paramètre les données à traiter et retournent en sortie les données traités. 
Les fonctions ont été développées à l'aide des API de communication Série du Beck  et correspondent à la fois aux normes imposées par les servomoteurs et à celles imposées par la communication Série.
Il existe ainsi des fonctions (modules) qui servent à :
\begin{itemize}
  	\item Ordonner aux servomoteurs de se placer à une certaine position avec une certaine vitesse de rotation qu'on a fixé : \textbf{set-Angle}. Elle prend en entrée l'ID du servomoteur en question et l'angle auquel il doit se positionner puis lui envoie la trame. 
  	\item Demander aux servomoteurs d'envoyer leurs positions courantes :\textbf{read-Angle} Prend en entrée l'ID du servomoteur dont on veut récupérer la position courante et envoie la trame de demande. 
  	\item Remplir la table de position des servomoteurs : \textbf{fill-DataAX12}.prend en entrée la table dans laquelle vont être stockées l'ID et la position du servomoteur.
  	\item Détecter les mises à jour de cette table puis les transférer à la table DATA CAN :\textbf{transfer-Data}. prend en entrées les deux tables DATA-AX12 et DATA-CAN et transfère les données de l'une à l'autre.
  	\item Gérer les 2 tables : \textbf{manage-Data}. Elle a besoin de la table qu'elle va gérer, détecte si elle est pleine et lui enlève les plus anciennes valeurs stockées.

\item Convertir la position en puissance et inversement : Elle dépend de l'entité à convertir (Angle/puissance)


\item Décoder  un message CAN provenant de FSUIPC en pilotage automatique : \textbf{decode-msg}. .Elle prend en paramètre  un pointeur vers un message CAN  duquel on va extraire les champs ID et Angle nécessaire à la communication avec les servomoteurs.

\item Créer un message CAN contenant l'ID du servomoteur en question et la position à laquelle il se trouve lorsqu'on est en pilotage manuel : \textbf{create-msg}. Elle prend en paramètre un message CAN, complète ses champs avec les informations contenues dans DATA-CAN, puis l'envoie à FSUIPC.
 \end{itemize}
Il est nécessaire de préciser que pour pouvoir utiliser les API du Beck, il faut inclure dans le code les bibliothèques dans lesquelles sont les API. Dans notre cas, nous avons inclus "Fossil.h" car ce qui nous concernait était la communication Série. Le reste des fonctions utilise des fonctions standards du langage C.
En outre, pour pouvoir recevoir et envoyer les messages CAN, nous étions en étroite collaboration avec l'équipe qui s'en occupait. Les bibliothèques qu'ils ont créées nous étaient d'une aide précieuse.

\textbf{Difficultés rencontrées:}
Dans le développement des modules le principal problème qu'on a rencontré est une mauvaise-compréhension des supports du Beck et l'insuffisance des documentations sur les servomoteurs. L'obtention de cette documentation à temps nous aurait facilité la tâche de développement. Avant la récupération de ces documents, nous nous sommes lancés dans un développement complexe des modules. Ce qui a certainement pénalisé l'avancement de cette partie du projet.
Avec cette documentation, mieux adaptée,  nos fonctions ont pu être simplifiées. Aussi un code plus simple, a facilité la correction des erreurs. Car non seulement les API sont plus simples mais aussi plus fiables.

Nous avons aussi rencontré des problèmes portant sur les formats de données. Alors que nous nous apprêtions à utiliser des formats de données sur 32bits, nous nous sommes rendus compte que ces derniers ne peuvent pas être traités par le Beck. Nous avons  donc opté pour la solution suivante : utiliser une structure de données qui aura comme champs (de 8 bits chacun) : l'ID et l'Angle (position).

\subsubsection{Développement de l'automate}

L'automate qui gère le transfert de données FSUIPC Servomoteurs a été intégré dans une boucle infinie afin d'avoir des informations en temps réel sur les positions auxquelles est le servomoteur et auxquelles il doit se mettre. Il a été conçu pour être déterministe afin de ne pas pouvoir se perdre dans un état.  
Comme il a été énoncé précédemment cet automate va faire interagir les différents modules développés. Ainsi, chaque état de cet automate va utiliser ces modules.
De l'état 1 à l'état 7, on est en pilotage manuel. Donc, les fonctions qui vont être utilisées seront celles qui interrogent l'état des servomoteurs, gèrent les données résultantes, et les transmettent au CAN.
De l'état 8 à 12, on est en pilotage automatique. Aussi, les modules qui y seront utilisées seront celles qui traiteront les messages CAN, les décoderont et enverront les données aux servomoteurs.
D'où cette liste d'appel de chaque module dans chacun des états : 

\begin{itemize}
\item Etat 1 : read-Angle(FOSSIL-COM, ID, output-Buff, nByteToRead );
\item Etat 2 : fossil-readblock(FOSSIL-COM, input-Buff, nByteToRead);
\item Etat 3 : fill-data-AX12(data-AX12, sizeDataAX12, input-Buff);
               dern-remplie(data-AX12, sizeDataAX12);
\item Etat 4 : transfer-data(data-AX12, data-CAN, sizeDataAX12, sizeDataCAN);
\item Etat 5 : create-msg-CAN(data-CAN, sizeDataCAN, msg );

\item Etat 10 : can-recv(1, ptrmsg);
\item Etat  11 : decode-Msg-CAN(ptrmsg,angle-Value, set-Angle-Buff).
 \end{itemize}

Dans cet automate, les temps de latence nécessaires à la réponse des servomoteurs ont été intégrés automatiquement du fait qu'entre l'envoi des trames d'instruction et la réception des trames de statut, les taches qui y sont effectuées couvrent suffisamment ce délai d'attente requis.
Cet automate intègre également une fonction can-msg-lookup(), qui surveille l'arrivée d'un message CAN.

\subsubsection{Réalisation de la carte interface}

La programmation du circuit GALisp22v10, a était faite en langage Abel à l'aide du logiciel Lattice IspDesignExpert, \ref{sec:schematic-ax12}, afin de réaliser la fonction half-duplex, expliquée dans la partie précèdente.
Les chronogrammes,\ref{fig:chronogramme half-duplex} , montre bien que la fonction réalise bien son rôle:

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/chronogramme-gal}
  }
  \caption{chronogramme half-duplex}
  \label{fig:chronogramme half-duplex}
\end{figure}

On remarque effectivement que lorsque Direction-port est à 1, TxD est transmis sur DATA, et RxD se met en haute impédance. Puis lorsque Direction-port est à 0, DATA est transmis vers RxD et TxD en haute impédance.

Pour la réalisation de la carte qui fait office d'interface entre le port rs232 et le servomoteur, nous avons opté pour un MAX233, car ce dernier éxige moins de condensateurs, ce qui facilite le routage du MAX232, qui lui possède 5 condensateurs, et ceci tout en gardant les mêmes propriétés.

Pour l'alimentation de la carte, nous avons utilisé un régulateur 7805T, capable de fournir une tension stable de 5v (output) en sortie afin d'alimenter le circuit GAL et le MAX233 et d'avoir une tension de l'ordre de 9.6v (input) pour l'alimentation des AX12.


\subsection{Tests et résultats}

Pour les tests, nous nous sommes placés dans les conditions suivantes :
\begin{itemize}
\item Un servomoteur non encore initialisé : on ne savait ni à quel débit il communiquait, ni quelle était ses positions limites alors que dans notre développement on a choisi des positions variant de 0° à 300° (0x0000 à 0x03FF)
\item Communication série mode RS232 initialisé à un débit de 57600 bauds, sans contrôle de flux grâce aux API qui y sont spécialement consacrés (FOSSILSETBAUD, FOSSILINIT, etc.).
 \end{itemize}
 
\subsubsection{Test de communication Beck-ax12}

En premier lieu, nous avons testé la partie pilote manuelle. Nous souhaitions vérifier que les servomoteurs reçoivent correctement les messages envoyés (Ex : Allumer la LED et se positionner à un angle donné).  
	Aucun octet de la trame n'était reçu par le servomoteur, il n'y avait aucune communication entre le Beck et les servomoteurs. Cependant le bon nombre de trames a  été correctement envoyé.
	Pour résoudre ce problème, il nous a fallu initialiser le servomoteur via le CM5. On lui a donné un débit de communication qui s'accorde avec celui du port série à défaut duquel aucune communication ne sera possible. Grâce à l'aide de \textit{Xynkui FENG}, cette initialisation a pu être effectuée.
	Nous avons recommencé les envois de trames d'essai vers le servomoteur. La réaction du servomoteur a été celle attendue (LED allumée, position changée). Cependant, on ne pouvait pas recevoir les trames de statut venant du servomoteur. Vu que ce qui nous intéressait était de récupérer la position du servomoteur contenue dans ces trames de statut, le résultat fut décevant. 
	La résolution de ce problème a nécessité une recherche approfondie sur les communications Séries du Beck. Nous nous sommes rendus compte que le signal RTS (qui contrôle le flux de données) ne basculait jamais de son état initial (à 1). Donc, le Beck était tout le temps en émission et ne pouvait rien recevoir. De plus, ce signal ne nous a pas été accessible, on ne pouvait pas le contrôler manuellement. 
Deux solutions ont été envisagées : 

\begin{itemize}
\item soit de relier, sur la carte d'interface entre le Beck et le servomoteur, les pins CTS et RTS afin que le CTS puisse être forcé à l'état haut une fois l'émission achevée.    
\item Soit de passer du mode RS232 au RS485. Ce dernier, permettant de contrôler même automatiquement le RTS/CTS, autoriserait la réception.
\end{itemize}

Aussi, nous avons opté pour la deuxième solution. En effet, elle était simple à réaliser, n'ayant que deux lignes de codes à écrire.
Le résultat a été en partie satisfaisant car nous avons pu recevoir des octets de la trame de statut. Donc le Beck  pouvait se placer en mode  réception. 
Néanmoins, on a du prendre en considération le temps de latence nécessaire au servomoteur pour réagir et envoyer la trame complète.
Ce problème résolu, on a pu passer à d'autres tests.

\subsubsection{Test des fonctions de remplissage des tables et de détection de mises à jour }

Dans un deuxième temps, nous avons testé si le remplissage des tables DATA-AX12 et DATA-CAN se fait correctement en affichant le dernier élément de chaque table. De plus, avec la boucle de l'automate qui tourne indéfiniment permet de tester si la gestion de la taille des tables s'effectue réellement comme on l'avait souhaité, qu'elle ne supprime que les plus anciennes valeurs. 
La gestion des tables se faisait comme on l'avait espéré. Le dernier élément des tables est bien la position la plus récente des servomoteurs.
On a essayé entre temps de changer la position du servomoteur au courant de la boucle, et la position affichée change en conséquence. 
Ce résultat a été prévisible car le fonctionnement de tous les modules est basé sur l'émission d'une correcte trame d'instruction et la réception de la trame de statut adéquate.

\subsubsection{Bilan de la partie commande des gaz }

Finalement, la communication Beck-Ax12 s'effectue correctement, comme nous l'avions espéré et aussi la gestion de l'arrivée des données  (remplissage des tables, détection de mises à jour et envoi des messages CAN). Cependant, la transmission Beck-CAN n'a pas pu être testée. On n'a donc pas pu vérifier si on envoie les trames correctes et si le simulateur réagi comme on l'aurait souhaité.


