\chapter{Capteur et actionneur}
\authors{
  \authorinfo{Romain}{Marchaudon} \\
  \authorinfo{Johnny}{Phor}\\
  \authorinfo{Salwa}{Bahji}\\
  \authorinfo{Alexandre}{Ouasin} \\
  \authorinfo{Chunlin}{Zhu}
>>>>>>> origin/master:doc/manual/capteur_et_actionneur.tex
}


\section{Commutateur et afficheur}
\subsection{Description et contexte}

Bloc Front Panel
Utilisation de circuits directement ineffaçables I2C : PCF 8575
Dans le cadre du projet il a étdemandde réaliser plusieurs parties distinctes du cockpit. Une de ces parties
correspond au front panel, et plus précisément la partie MCP ajoutau contrôle des trains d'atterrissages de
l'avion. Il existait deux solutions que nous avons prises en compte pour gérer les actions provenant de l'appui
sur ces boutons :
\begin{itemize}
  \item L'utilisation du FPGA
  \item L'utilisation du PCF8575.
\end{itemize}
C'est cette dernière solution qui a étretenue. En effet elle présentait l'avantage d'être la fois rapide 
mettre en oeuvre et de plus les circuits PCF8575 sont directement compatible I2C. De plus la solution FPGA,
même si elle permettait de limiter le nombre de circuits utiliser dans le cockpit, augmentait la charge
du FPGA et aller certainement faire perdre du temps dans sa mise en place en raisons des tests que nous
aurions du effectuer dessus.

Pour finir, lors du développement du code I2C sur les contrôleurs BECK, les circuits PCF8575 que nous avions notre disposition ont servit éprouver le fonctionnement du code implantsur les BECK. De cette manière il était déjsur que ces circuits fonctionneraient parfaitement avec l'ensemble de la chaine de traitement implantée dans le cockpit.

Le MCP du cockpit n'ayant jamais éten notre possession temps, nous avons du faire avec les informations
disponibles pour connaitre le nombre de boutons, diodes, commutateurs position et encodeurs incrémentaux 
interfacer. Pour faciliter les choses, nous avons choisi de regrouper sur les circuits PCF les boutons poussoirs
entre eux, les diodes également et de la même manière les commutateurs positions. De cette manière nous utilisons
actuellement 6 circuits PCF pour l'ensemble de ce bloc. Ce dernier est composcomme ceci :
\begin{itemize}
  \item 32 diodes implantées sur 2 PCF8575
  \item 25 boutons poussoirs pour 2 PCF8575
  \item Nyanya commutateurs positions pour les deux derniers PCF8575 utilisés.
\end{itemize}
Cette disposition a étdécidée avec le groupe BECK afin de faciliter la lecture et l'écriture sur les PCF. 
En effet, de cette manière les PCF sont soit en lecture (boutons poussoirs et commutateurs positions) ou bien en écriture (diodes). Nous avons également décidde ne brancher que 32 diodes sur les 33 pour des facilités de 
routage et éviter d'utiliser un circuit supplémentaire pour une seule sortie sur les seize disponibles. De plus 
la présence de cette 33 ème diode n'a pu être éprouvée du fait que nous ne disposons pas des blocs sous les yeux.
en effet un doute persiste sur la présence ou non de cette diode qui aurait alors une lumière blanche 
(et non jaune) et dont l'utilitn'a pas étvraiment prouvée. De plus comme nous l'avons vu avec monsieur 
Bouaziz, l'interfaçage des boutons, diodes et commutateurs sur le FPGA serait une solution plus stable dans le
temps, et sera donc a priori la futur solution dans le cockpit. En effet, de cette manière,  tous les composants
seraient alors interrogés de la même manière, et plus besoin d'utiliser un nombre d'adresses limités avec les PCF,
ces derniers n'ont que 3 bits modifiables dans leur adresse ce qui limite le nombre de PCF 8 sur chaque bus I2C.
Néanmoins même dans ces conditions, le front panel et la console centrale peuvent voir leurs boutons, 
commutateurs et diodes interfacées sur les PCF8575.

Au niveau du fonctionnement des PCF, il a été décidé brancher les diodes en pull-up. De cette manière, 
il faudra appliquer un niveau zéro sur le PCF pour allumer une diode. De leur côté, les boutons 
poussoirs et commutateurs positions seront fermés pour un niveau 0 dominant constaté sur les PCF.Nous relierons
donc l'ensemble des commutateurs et boutons poussoirs à la masse.

Au niveau des afficheurs,  nous avons choisi d'adopter l'afficheur 7 segments plutôt que des écrans LCD.
Ceci colle plus au matériel qui se trouve dans les cockpits réel. Afin de valider ce bloc fonctionnel,
nous n'avons décidé d'afficher une seule valeur car tous les afficheurs du cockpit fonctionnent de la même manière.
Comme nous disposons d'une chaine complète et fonctionnel pour l'altitude (de l'encodeur incrémental
jusque FSX) nous avons décider de tester l'affichage de ce paramètre sur le MCP.

Une carte avec interface I2C disposant de 4 afficheurs 7 segments est à notre disposition.
C'est le circuit intégré SAA1064 qui est implanté sur la carte et permet de faire le multiplexage entre
les différents afficheurs. Chaque SAA1064 dipose de 2 bits modifiables dans leurs adresses ce qui limite
le nombre des cartes à 4 sur chaque bus I2C.
Cela pose des  problèmes si on veut afficher tous les paramètres sur le même bus I$^2$C, par contre l'avantage du
SAA1064 est la possibilité de changer l'intensité d'affichage pour les segments.

Nous avons programmé un compteur de 0 à 9999 pour tester l'affichage d'altitude.

Du coté du BECK, il a été demandé de réaliser la détection d'appui sur une touche ou du  changement de position des 
commutateurs à positions et aussi de réaliser l'actualisation de l'affichage.

Pour la première partie, c'est à dire la détection de 
changement des données de PCF. Il suffit de lire les données de PCF via bus I$^2$C et de comparer avec les anciènes valeurs stockées préalablement dans le BECK.
Si un changement est détecté, les données de PCF seront remplacées par les nouvelles. Le BECK va envoyer le 
message CAN correspondant comportant les nouveaux états des touches et les positions des commutateurs au PC. 
Pour actualiser l'affichage, chaque fois qu'un message CAN visant à modifier l'affichage arrive, le BECK le 
traite et envoie les données reçues à l'afficheur correspondant.

Etant donné que la détection d'appui sur une touche et le changement de position d'un commutateurs dure
beaucoup plus longtemps que l'actualisation de l'affichage, un TIMER est utilisé pour que le message CAN reçu
ne soit pas perdu, tout en sachant que la pile du BECK enregistrant le message dispose d'une taille limité.
De plus, il est possible de s'assurer que l'actualisation d'affichage soit traitée à temps.
L'automate est représenté en figure \ref{fig:Automate_PCF}

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/Automate_PCF}
  }
  \caption{Automate de PCF}
  \label{fig:Automate_PCF}
\end{figure}

Comme un appui sur une touche dure environ 100 ms, le choix d'un TIMER de 50 ms est raisonnable.
De cette manière tout appui peut être détecté à coup sur. Pendant le test, nous avons utilisé un PCF dont les
16 pattes ont été connectées à un niveau 1 récessif. une des pattes à ensuite été connectée à la masse,
de la même manière que pour l'appui sur une touche. Le PcCANView a bien reçu le message CAN envoyé par le 
BECK. Pour tester l'actualisation d'affichage, nous avons utilisé le PcCANView qui permet d'envoyer un message
CAN au BECK. Nous avons alors pu visualiser l'affichage de valeur envoyée au travers du message CAN.

Au début du test, nous nous sommes trompé de niveau dominant. Nous avions pensé à mettre un niveau 1 dominant
dans le circuit. Mais nous avons constaté que c'était toujours un niveau 0 dominant.
Il a donc fallu connecter les boutons à la masse. L'autre problème rencontré est pour lire les 
pattes de PCF. En effet il faut s'assurer que le registre d'écriture est à 0Xffff avant d'effectuer une lecture.
Pendant la programmation, nous avons également rencontrer des problèmes de pointeurs de fonctions. 
La nouvelle valeur ne remplaçait alors pas l'ancienne.

\section{Encodeur incrémental}
\subsection{Contexte et objetctif}
\subsection{Conception et choix technique}
\subsection{Développement}
\subsection{Résultat}


\section{Clavier matriciel}
\subsection{Contexte et objetctif}
\subsection{Conception et choix technique}
\subsection{Développement}
\subsection{Résultat}

\subsection{Objectifs du bloc}



Le but de ce bloc est d’interfacer un clavier matriciel tel que celui décrit sur la figure suivante afin que le maître du bus I2C puisse reconnaître quelle touche est actionnée. Le clavier matriciel a autant de colonnes et de lignes à relier pour en déduire l’information utile (appui ou non d’un bouton poussoir). Dans notre cas, cela implique 8 colonnes et 9 lignes. Le FPGA étant un processeur bénéficiant d’un nombre d’entrée/sorties important, il est une interface adéquate à clavier (9+8=17 entrées/sorties).

La matrice ainsi câblée, autorise des niveaux 1 récessifs par défaut, c’est-à-dire sans action direct du FPGA. Chaque ligne et chaque colonne sont reliées bidirectionnellement au FPGA.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/schema_clavier_matriciel}
  }
  \caption{Automate de PCF}
  \label{fig:Automate_PCF}
\end{figure}


\subsection{ Solutions envisagées & limites }

	Dans un premier temps, nous avons envisagé que le FPGA traite les informations lui-même en en mettant en place le protocole de détection de touche. Une requête de lecture du clavier étant détectée, le FPGA renvoie la valeur associée de la dernière touche appuyée (de 1 à 72). Si cette valeur a déjà été envoyée et que l’on détecte une nouvelle requête de lecture de la part du beck, le FPGA renvoie la valeur 0.

	Cette solution implique une certaine simplicité du traitement sur le reste de la chaîne de commande, en contrepartie, elle demande un algorithme trop important à mettre en place au sein du FPGA 
\subsection{ Solution retenue & ses forces et avantages}

	La solution retenue au sein du FPGA est d’autoriser en lecture et en écriture les lignes et les colonnes de notre matrice. Le traitement direct de détection de touche se fait alors sur le maître du bus I2C. Nous avons gardé les tailles génériques des registres utilisés auparavant. Les lignes sont codées sur 2 octets c'est-à-dire sur 2 registres, de même pour les colonnes. Certains bits correspondants aux lignes (8 bits) et aux colonnes (7 bits) ne sont pas reliés physiquement, toutefois, cela n’affecte en rien le traitement de l’information.

	Les registres de lecture et d’écriture sont illustrés sur la figureXXX. Un registre d’écriture (à droite) correspond à un registre de lecture (à gauche) dans le cas du clavier matriciel.



\section{Commande des gaz}
\subsection{Description et contexte}

Pour la commande des gazs on veut être capable de contrôler les moteurs et le trim . On souhaite avoir accès aux commandes en position et en détection de dépassement de couple.

Nous souhaitons être capable d'envoyer, d'une part, vers FSUIPC les différentes positions des servomoteurs et dans le sens FSUIPC vers les AX12, autrement dit le mode pilote automatique,  les servomoteurs doivent être capables de se positionner à des angles bien précis. 
Pour cela on doit interfacer les servomoteurs avec le bus CAN. On doit donc adapter les formats de trames, venant des servomoteurs ou venant du bus CAN, afin que ces deux entités puissent communiquer entre elles.

Pour la réalisation des commandes de gaz nous utiliserons des Servomoteur Dynamixel AX12. Les AX12 sont pilotés par une liaison série et peuvent être reliés l'un à l'autre pour créer une chaîne de servomoteurs .Nos 3 servomoteurs peuvent donc cohabiter sur un même bus.
Ces moteurs ont une résolution de 1024 pas et une vitesse réglable également sur 1024 pas. En lecture, il est possible de connaître, entre autres, leur position courante et leur couple ce qui correspond bien à nos besoins.

\subsection{Conception fonctionnelle}

Quand on étudie la documentation du Servomoteur Dynamixel, on remarque que ce dernier peut être contrôlé par un PC via un CM-5.
Le CM-5 possède un circuit interne qui permet de convertir les signaux en half-duplex. Le diagramme réalisant cette conversion est \ref{fig:half_duplex}:

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/half_duplex}
  }
  \caption{half_duplex}
  \label{fig:half duplex AX12}
\end{figure}

On souhaite donc, que les signaux, de niveaux TTL, RxD et TxD dépendent du signal Direction_Port.
Lorsque le signal Direction_Port est au niveau haut, le signal TxD en sortie représentera DATA et lorsque, le signal Direction_Port est au niveau bas, le signal DATA est l'entrée du signale RxD.
On constate donc qu'on peut s'affranchir du CM5, d'une part à cause de son coût élevé (60€) et d'une autre part pour notre propre apprentissage, en réalisant une carte électrique qui produirait cette fonctionnalité du CM5.

Pour cela on pourra utiliser un GALisp22V10, qu'on implémentera via Abel.
D'autre part le GAL fonctionne avec des niveaux TTL alors que le port série fonctionne avec des niveaux logiques 1 et 0, notre carte d’interface devra également générer des niveaux TTL. Pour cela on pourra utiliser un MAX232, qui amplifie et met en forme deux entrées et deux sorties TTL/MOS vers deux entrées et deux sorties RS232. 
Cette carte nous permettra également d'obtenir le signal data nécessaire pour le servomoteur AX12, via le GALisp, qui est également à un niveau TTL.

\subsection{Developpement et problèmes rencontrés}
La programmation du GAlisp22v10, a était faite via Abel, cf.ANNEXE Abel_GAL, afin de réaliser la fonction half_duplex, expliquée dans la partie précédente.
Les chronogrammes, en ANNEXE Chronogrammes GAL, montre bien que la fonction vérifie bien son rôle.

Pour la réalisation de la carte qui fait office d'interface entre le port rs232 et le servomoteur, nous avons opté pour un MAX233, car ce dernier exige moins de condensateurs, ce qui facilite le routage par rapport au MAX232, qui lui possède 5 condensateurs, tout en gardant les mêmes propriétés.

Pour l'alimentation de la carte, nous avons utilisé un régulateur 7805T,  capable de fournir une tension de 5v (output) en sortie afin d’alimenter le GAL et le MAX233 et d'avoir une tension de l’ordre de 9.6v (input) pour l'alimentation les AX12 \ref{fig:7805}:

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/7805}
  }
  \caption{7805}
  \label{fig:7805}
\end{figure}








 




