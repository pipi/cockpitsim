\chapter{Module CAN et généricité}
\authors{

  \authorinfo{Alexandre}{Ouazan}  \\
  \authorinfo{Julien}{Peeters} \\
  \authorinfo{Johnny}{Phor}  \\
  \authorinfo{Fabien}{Provost} \\
  \authorinfo{Feng}{Xiong} \\
  \authorinfo{Yongchao}{Xu} \\
  \authorinfo{Chunlin}{Zhu}
  
}

\section{Description et contexte}
L'objecif de cette partie est de créer des outils permettant de simplifier l'utilisation des différents bus de manière générique de façon à pouvoir être réutilisés à plusieurs endroits du projet.

Seront vu dans cette partie, la conception et le développement des noeuds CAN qui permettent de recevoir 
des messages CAN et de les interprêter afin de générer les actions adéquates (envoie de messages I$^2$C par 
exemple) et inversement (envoie de message CAN après utilisation d'un actionneur), aussi nous verrons
l'utilisation d'un FPGA comme interface au bus I$^2$C, c'est à dire que le bloc qui permet de connecter 
des DEL, des boutons poussoirs ou autres composants plus complexes à un bus I$^2$C. 

\section{Module périphérique sur bus I$^2$C: réalisation VHDL}
\subsection{Objectifs}

Afin d'interfacer les différents éléments du FCU (Flight Control Unit) tels que les commutateurs de position, les encodeurs numériques et les switchs, au contrôleur central du noeud (contrôleur BECK), il est nécessaire de définir un protocole de communication. 

Après l'avoir choisi, l'étape suivante était de déterminer par quel biais les éléments du FCU allaient communiquer. En effet, ces derniers ne sont pas des composants I$^2$C et par conséquent ne peuvent être directement connectés sur les lignes de communication. Un module doit donc être greffé servant d'interface entre les lignes I$^2$C et les différents encodeurs incrémentaux, boutons poussoirs etc... 

Deux choix possibles existent. La première, utiliser un microcontrôleur. Ses avantages ne sont pas négligeables et la principale étant son langage de programmation. En effet, le langage C suffisait et était de plus connu des membres de l'équipe. Par ailleurs, les microcontrôleur sont pré équipés d'un module I$^2$C 'hardware' qui permettrait de simplifier sa mise en oeuvre. 
Mise à part cela, ils peuvent être limités en termes de puissance de calcul ainsi qu'en nombre de port IO disponible, nécessitant donc en plus l'implantation d'autres composants (multiplexeur, registre,...) surchargeant la carte.
 
La deuxième possibilité, celle qui a été retenue, est d'utiliser un circuit programmable type FPGA et d'y utiliser le langage VHDL. La difficulté se situe donc au niveau de l'apprentissage de ce nouveau langage de description, de son comportement et de ses subtilités. Le FPGA ne possède pas d'interface I$^2$C pré implantée ce qui obligeait à la concevoir en VHDL. Cependant, ce circuit programmable présente d'énormes qualités dans le cadre du projet. Il possède un nombre d'entrées/sorties supérieur à 60, et il a de bonnes capacités de calcul. De plus, utiliser un composant tel que celui-ci en plus du VHDL est une très bonne expérience pour nous apprentis ingénieurs.

Le langage VHDL donne, par ailleurs, la possibilité de réaliser des blocs fonctionnels indépendants et de les assembler schématiquement. Ainsi, la gestion des éléments du FCU peut être indépendante du bloc de gestion I2C et la conception grandement simplifiée. 

Par soucis de réalisation, la conception du module sur circuit logique programmable FPGA à été préférée à celle sur microcontrôleur, puisse qu'il offrait des possibilités plus importantes.

\subsection{Solution envisagée}
La création de ce module interfaçant I$^2$C et les éléments du FCU devait répondre à un cahier des charges fixés décrivant les protocoles de communication entre 'maître' et 'esclave' I$^2$C. Il a été choisi par soucis de simplification qu'il n'existerait qu'un unique 'maître' sur la ligne de communication. Celui-ci  ne pourra donc jamais rendre la main et donc sera le seul à avoir le contrôle du bus. Cela implique qu'il ne peut obtenir d'informations que par requête auprès des différents éléments du FCU.  
De plus, plusieurs éléments du FCU étant reliés au FPGA, nous avons donc décidé en accord avec l'équipe BECK d'associer à chacun, un identifiant I$^2$C unique. Ainsi, le FPGA serait non pas un esclave I$^2$C en tant que tel mais plutôt une réelle interface. Il émule donc autant de noeuds esclaves qu'il existe d'éléments reliés.  Ces derniers seront donc considérés comme esclave I$^2$C. 
Schématiquement, les communications entre 'maître' et 'esclave' I$^2$C se déroulent principalement suivant la figure \ref{fig:SI2C_c1}

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/SI2C_com1}
  }
  \caption{Communication I2C avec bloc non générique}
  \label{fig:SI2C_c1}
\end{figure}

En résumé, le 'maître' envoie une trame aux 'esclaves' contenant l'identifiant de l'élément souhaité.  Si l'esclave a bien acquitté à la demande du maître, son unique réponse ne peut être que de renvoyer sa valeur.
L'avantage est que cet échange ne demande donc que d'établir une unique trame de trois octets (un octet issue du maître et deux octets de  l'esclave). 

\textit{Remarque }: l'identifiant est, d'après la définition générale du protocole I$^2$C, sur 7 bits et un bit de lecture/écriture (R/W) vient compléter l'octet à envoyer. 

Cependant, un bloc esclave I$^2$C créé de cette façon présente un énorme inconvénient à savoir sa généricité. En effet, tel quel, le bloc ne peut être utilisé que dans un type de configuration I$^2$C, c'est-à-dire " le maître demande, un esclave répond par sa valeur ". Aucune information ne peut donc être envoyée à l'esclave pour qu'elle soit éventuellement traitée par celui-ci. De plus, un nombre croissant d'esclave I$^2$C deviendrait rapidement contraignant à implanter au niveau du FPGA étant donné que pour chaque noeud, un bloc esclave I$^2$C devra être émulé.
Cette solution à donc été abandonnée étant donné le fait que le bloc doit pouvoir être réutilisable dans d'autres modules du projet.

Nous avons dû effectuer une refonte du cahier des charges tenant compte des nouvelles contraintes imposées. A savoir que le bloc I$^2$C devait être réutilisable donc générique. De cela découle d'autre contrainte, c'est-à-dire la possibilité de récupérer des données provenant du maître. Cette récupération de données devra se faire tant que le maître n'aura pas imposé de condition de stop. 

Par ailleurs, le maître décidera du nombre d'octet que l'esclave devra lui envoyer dans une procédure de lecture du maître et ne pourra être interrompu que par une condition de stop. Cela permettra donc de connecter au FPGA des éléments fournissant une donnée dont la taille est supérieure à deux octets (cas précédent). Cela demande donc au préalable que le maître connaisse la taille de la valeur renvoyée par l'esclave I$^2$C.  
De plus, pour palier au problème d'excès d'esclave I$^2$C et donc de bloc I$^2$C associé, nous avons décidé de ne considérer qu'un bloc I$^2$C. Ainsi, c'est maintenant le FPGA qui est l'esclave I$^2$C. Cela impose une nouvelle définition des trames de requête.

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/SI2C_com2}
  }
  \caption{Communication I2C avec bloc générique}
  \label{fig:SI2C_c2}
\end{figure}
En récapitulatif, les nouveaux éléments à apporter : 

\begin{itemize}
\item Généricité du bloc
\item Possibilité de récupération de donnée
\item Nombre d'octet à renvoyer déterminé par le maître
\item Le FPGA est l'unique esclave I$^2$C
\end{itemize}

Les éléments du FCU n'étant plus identifiés par leur identifiant I$^2$C, ils le seront à présent par une adresse unique que le maître devra fournir après avoir établie la communication avec le FPGA. Cette adresse permettra au FPGA de pointer à tout instant sur un registre correspondant. 


Dans le cas où le maître n'aurait pas généré de condition de stop pour arrêter l'envoie de données par l'esclave, il est prévu d'auto incrémenter l'adresse à laquelle le pointeur de registre doit pointer. De cette façon, il est possible de lire deux registres successifs pouvant représenter une valeur d'un même élément sur 16 bits. 

Schématiquement, les communications entre 'maître' et 'esclave' se déroulent comme en figure \ref{fig:SI2C_c2}

\begin{figure}[htpb]
  \centering
  \fbox{
  \includegraphics[scale=0.7]{images/diagramme_slave_i2c}
  }
  \caption{Automate de l'esclave I2C}
  \label{fig:SI2C_autom}
\end{figure}

En résumé et toujours en partant du principe que le FPGA ne peut pas prendre le contrôle du bus I$^2$C, l'interrogation du FPGA doit se faire par une demande d'écriture du maître donnant l'adresse du registre puis une demande de lecture. L'esclave répond par un envoi de données lues dans le registre pointé.

\subsection{Réalisation et description de l'automate I$^2$C esclave}

En tenant compte du nouveau cahier des charges, on est en mesure de réaliser l'automate de base de l'esclave I$^2$C (figure : \ref{fig:SI2C_autom}).

Le premier état 'idle' correspond à l'état de repos du bus I$^2$C c'est-à-dire lorsque les lignes SDA et SCL sont au niveau logique '1' récessif. L'automate restera donc toujours dans cet état à moins d'une détection de condition de 'start' qui a été découpée en deux phases (la première phase étant détectée dans 'Idle') afin d'éviter les erreurs. 

L'état 'clockTime' permet la détection de la seconde phase de condition de 'start'.
Une fois la détection faite, il s'agit de lire l'identifiant et le bit de lecture/écriture envoyé par le maître dans l'état 'readAdd'.  Ceci fait, on regarde si l'identifiant est bon. Si tel est le cas, il s'agit alors de déterminer si le maître a envoyé une requête de lecture ou d'écriture (état 'bitRW').
 
Dans le cas d'une demande d'écriture, on lit l'adresse du registre à pointer.  Si aucune condition de 'stop' n'est détectée, c'est que le maître désire maintenant écrire des données dans le registre initialement pointé. 

Dans le cas d'une demande de lecture, on envoie la valeur du registre que le pointeur pointe (l'adresse du registre étant fixée précédemment). Si aucune condition de 'stop' n'est détectée, c'est que le maître désire maintenant lire les données dans le registre de l'adresse suivante. 

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/SI2C_bloclink}
  }
  \caption{Architecture du bloc esclave I2C}
  \label{fig:SI2C_blink}
\end{figure}

Au premier abord, cet automate fonctionne en simulation. Cependant, ainsi fait, il n'est pas certain que celui-ci fonctionne en condition de test sur maquette. En effet, cet automate à été créé sans tenir compte des erreurs pouvant se produire en condition réelle. Une condition de 'start' ou 'stop' générée par le maître pendant l'envoie d'une trame, par exemple, signifiant que le maître a annulé son premier envoie de trame, etc...
Ainsi, il est nécessaire entre chaque étape de l'automate de détecter la présence ou non d'une condition de 'start' et 'stop'.

\subsection{Test de validation et résultat}

La difficulté ici résidait dans le test du module. En effet, ne disposant que de très peu de matériel, il était difficile de générer des trames I$^2$C pour savoir si le bloc I$^2$C répondait correctement. Le test a tout de même été réalisé en connectant un microcontrôleur BECK au FPGA équipé d'encodeur numérique pour faire varier les valeurs des registres. 
La procédure était donc de faire envoyer une trame de demande d'écriture par le BECK, puis une trame de demande de lecture. Alors, le microcontrôleur BECK devait lire cette valeur de retour et l'afficher à l'écran. En faisait varier la valeur des registres pointés, la valeur affichée à l'écran devait à son tour changer. 

L'identifiant 7 bits I$^2$C du module esclave était '1100 100'. L'envoi d'une demande d'écriture signifiait l'envoi du premier octet '1100 1000' avec pour bit de poids le plus faible le bit d'écriture. Suivait ensuite l'adresse sur laquelle le pointeur de registre devait pointer, ici l'adresse '0000 0000'. Une demande de lecture est envoyée avec l'identifiant '1100 1001'. L'esclave répond par un envoi de données.

La description de la procédure de test est la suivante :

\begin{enumerate}
\item Le BECK envoie une trame de 2 octets : '1100 1000' '0000 0000'
\item Le BECK envoie une trame de 1 octet : '1100 1001'
\item Le FPGA répond sur la même trame : 'xxxx xxxx' 'xxxx xxxx' (valeur registre)
\end{enumerate}
	
Afin de se rendre compte du fonctionnement de l'auto incrémentation du registre, il suffisait de demander une donnée de retour sur 4 octets et non plus sur 2. Ainsi on lit les registres suivants successivement : '0000 0000', '0000 0001', '0000 0010', '0000 0011'.

Les tests ont été passés avec succès et ainsi le module a pu être validée.

\section{Interface USB/CAN}
\subsection{Objectfis}
L'objectif de cette partie du projet est de fournir l'implantation de l'interface CAN décrite dans la section \ref{sec:bibliotheques}.
Comme nous l'avons expliqué précédemment, ne avons mis en place une API \footnote{Acronyme de l'anglais Application Programming
Interface, qui décrit l'interface - les fonctions disponibles - d'une partie ou de la totalité d'un programme.} homogène pour tous 
les noeuds du bus CAN, il s'agit donc ici de réaliser l'implantation de cette API pour les programmes qui tourneront sur PC.

Pour cela, nous avons à disposition un module USB/CAN, qui se connecte donc en USB sur les PC et fourni deux interfaces CAN -
cependant nous n'en utiliserons qu'une dans le cadre de ce projet. Une libraire est également fournie par le constructeur. Notre
travail s'est donc concentrée sur la compréhension du fonctionnement de cette librairie, sur le développement de l'implantation des
fonctionnalités que nous désirions avoir et sur la validation du code produit en procédant à des tests.

\subsection{Conception}
La conception de cette partie du projet n'a pas révélé de problèmes majeurs. Le travail le plus important en temps et en réflexion
fût de comprendre le fonctionnement de la librairie - en particulier la compréhension de sa API. En effet, plusieurs produits
existent dans la gamme du constructeur et la librairie fournie est prévue pour être compatible avec tous l'ensemble de la gamme, ce
qui implique des redondances au niveau de l'API même et une difficulté supplémentaire pour connaître les fonctions qui nous intéresse
dans le cadre de notre application.

Alors que nous étions encore dans la phase de conception, nous nous sommes rendu compte que les librairies sur les systèmes BECK et
PC présentaient certaines différences significatives, principalement regroupées autour du concept de \emph{fonction bloquante}
\footnote{Une fonction est dite bloquante si, après être appelée, elle peut se bloquer tant qu'elle n'est pas capable de produire 
un résultat. Cela à pour effet de bloquer les programmes \emph{mono-threadés}.} Il a donc fallu contourner cette difficulté. Nous avons
pris le parti de rendre transparent la non utilisation des propriétés bloquante sur la partie PC, permettant ainsi de ne pas impacter
sur l'implantation faite sur le BECK - l'API ayant déjà été arrêtée en amont, nous avons préférer minimiser les changements pour gagner
du temps.

\subsection{Développement}
Le développement quant à lui s'est strictement limité à l'assemblage des différentes fonction formant notre API CAN. Grâce aux
points étudiés lors de la conception, la partie développement s'est très bien passée. Les erreurs étant minimes et très vite corrigées.

\subsection{Tests et résultats}
Pour la réalisation des tests sur cette partie du projet, nous avons utilisé un outil fourni par le constructeur du module USB/CAN.
Ce dernier permet de scruter les trames qui transitent sur le bus et d'en afficher les informations (identifiant, données, taille,
période, occurence). Ce fût fort utile, car il nous a suffit de générer quelques trames modèles choisies arbitrairement pour mettre en
évidence les erreurs possibles et de vérifier l'exactitude des données grâce à l'outil du constructeur.

Les tests se sont conclus très rapidement par de très bons résultats.

\section{Interface CAN/I$^2$C}
\subsection{Objectifs}
L'objectif de ce module est donc double:
\begin{itemize}
\item la recherche de modifications sur le bus I$^2$C, puis envoi des changements par messages CAN
\item traiter les messages CAN reçus et envoi de messages I$^2$C aux esclaves concernés 
\end{itemize}

\subsection{Conception}
Tout d'abord, afin de pouvoir utiliser le bus CAN et le bus I$^2$C, nous avons utilisé la blibliothèque que l'on a créé can-i2c.h.
D'un autre côté, sur le fichier main.c, on a créé une structure (i2c-can-trans-t)permettant de stocker:


\begin{itemize}
\item un identifiant CAN unique pour chaque élément de cette structure,
\item l'identifiant I$^2$C de l'esclave qui est concerné par les messages CAN dont l'identifiant est le même que ci-dessus,
\item la dernière valeur lue à parir de cet esclave (qu'on appelera old-value),
\item et d'autres informations commme la taille des données.
\end{itemize}


Cette structure (i2c-can-trans-t) a une rôle primordial ici, car elle va nous permettre de faire le lien entre messages CAN et messages I$^2$C.
Nous avons donc créé un tableau de cette structure pour regrouper chaque identifiant CAN qui intéresse le noeud CAN, ainsi nous avons pu aisément faire correspondre les messages CAN et les messages I$^2$C.
Pour utiliser ce tableau nous avons donc trois fonctions particulières:

\begin{itemize}
\item i2c-changes-lookup qui détecte les changements sur les esclaves I$^2$C et met à jour la valeur dans le tableau
\item i2c-send-changes qui appel i2c changes lookup et qui envoie un message CAN s'il y a eu un changement (ces deux fonctions sont synthétisées sous forme d'un diagramme d'état en figure \ref{fig:bibliotheques}).
\item update-values qui à la réception d'un message CAN, va envoyer un message I$^2$C aux esclaves correspondant afin de mettre à jour leur valeur.
\end{itemize}


\subsection{Développement}

La fonction i2c-changes-lookup prend en paramètre un élément de type i2c-can-trans-t et interroge l'esclave I$^2$C, compare la valeur obtenue à l'ancienne valeur lue, s'il y a une différence on met à jour et on retourne '0', sinon on retourne '-1'(voir figure \ref{fig:automate_i2c_lookup}).

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/diagramme_i2c_changes_lookup}
  }
  \caption{Automate i2c-changes-lookup}
  \label{fig:automate_i2c_lookup}
\end{figure}

%IMAGE

La fonction i2c-send-changes prend en paramètre le tableau de i2c-can-trans-t, le parcourt et applique i2c-changes-lookup pour chaque élément. Après un test de la valeur de retour, si on a 0 on envoie un message CAN avec, en identifiant, l'identifiant CAN stocké dans le i2c-can-trans-t, et en data la valeur stocké dans le i2c-can-trans-t(voir figure \ref{fig:automate_send_changes}).

\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/diagramme_i2c_send_changes}
  }
  \caption{Automate i2c-send-changes}
  \label{fig:automate_send_changes}
\end{figure}

%IMAGE
La fonction update-values va prendre en paramètre le tableau de 'i2c-can-trans-t', sa taille et le message CAN à traiter. En parcourant le tableau, on compare l'identifiant du message aux identifiants CAN du tableau, lorqu'on a trouvé l'élément de 'i2c-can-trans-t' qui a le bon identifiant, on va envoyer un message I$^2$C avec pour identifiant, celui stocké dans le 'i2c-can-tran-t', et pour data, la même data que le message CAN reçu, enfin cette fonction met à jour la valeur de 'old-data' qui est égale à la valeur de data du message CAN reçu (voir figure \ref{fig:automateCAN-I2C}).


\begin{figure}[htpb]
  \centering
  \fbox{
    \includegraphics[scale=0.5]{images/automate-CAN-I2C-G}
  }
  \caption{Automate général}
  \label{fig:automateCAN-I2C}
\end{figure}


\subsection{Tests et résultats}

Les tests ont été faits rapidement sur des afficheurs 7 segments. Pour cela, nous avons utilisé un logiciel PCcanView pour envoyer un message CAN qui devait écrire sur un afficheur 7 segments branché en I$^2$C. Cette expérience permettait de valider la fonction 'update-values'.
Les résultats furent concluant après quelques essais.

Pour les deux autres fonctions, il a fallut utiliser des PCF interfacés en I$^2$C. Cela a necessité beaucoup de temps pour
que le message CAN envoyé par le BECK après changement soit correct (notamment la DATA). Ce délai est dû à l'ordre où était envoyé les octets des DATA.

Maintenant ce bloc est fonctionnel.


