\chapter{Etat final et possibilitées d'évolutions}
\authors{
  \authorinfo{prénom}{nom} \\
}

\section{Évolution de FSadapter}
Étant donné que tout le materiel nécessaire n'était pas disponible, nous avons décidé de prouver le concept de la réalisation du cockpit, en interfaçant un bouton permettant d'incrémenter la valeur de l'altitude. Les fonctions permettant d'utiliser cette valeur ont donc été écrites. Par contre, les autres fonctionnalitées n'ont pas été ajoutées au simulateur. Autrement dit, pour chaque réalisation matérielle faite sur le cockpit, des adaptations doivent être réalisées dans le programme. Les trames doivent ainsi être réalisées pour toutes les données qui sont ajoutées au simulateur, et les fonctions de traitement (dans le sens CAN vers FS et FS vers CAN) doivent être écrites pour chaque famille de données, et (le plus important) les données obtenues par le bus CAN doivent être reliées aux valeurs fournies par FSUIPC.

\section{Évolution de l'interfaçage des éléments extérieurs au microcontrôleur BECK}
Jusqu'à présent, tous les éléments  interfacés sur le bus I2C, à savoir switchs, commutateurs à positions, encodeurs incrémentaux, ...  sont systématiquement interrogés par FSAdapter via les microcontrôleurs BECK. Cette solution n'est vraisemblablement pas la meilleure. En effet, les interrogations de manière continue nécessitent une énorme charge de travail sur  FSAdapter ou tout du moins une forte utilisation du le bus CAN. Ce qui est d'autant plus vrai qu'il y a beaucoup d'éléments à interroger.

La majorité des requêtes envoyées par FSAdapter ne sont pas utiles puisqu'aucun élément n'a changé de valeur.  L'amélioration qui peut donc être envisagé est de ne plus demander à FSAdatper de faire des interrogations continues vers les éléments I2C mais de faire en sorte que les composants extérieurs puissent envoyer un message dès qu'un évènement à eu lieu (i.e. un commutateur change de position, il doit générer un message vers FSAdapter sans aucune interrogation de ce dernier). Ainsi tous les éléments extérieurs doivent être capables de générer des interruptions pour avertir d'un changement et prendre en compte des conflits, en particulier sur le bus, pouvant survenir si jamais plusieurs éléments sont manipulés en même temps. 

Par conséquent, cela nécessite de repenser le bloc I2C du FPGA, dans le cas où ce type de structure est capable de générer des interruptions. Dans le cas où cela serait possible, il faudrait donc pouvoir intégrer un master ou remplacer l'esclave par un maître I2C afin qu'il puisse prendre le contrôle du bus et générer une trame I2C en destination de FSAdapter. Si le FPGA n'était pas en mesure de générer ce type d'évènement, la piste du microcontrôleur pourrait éventuellement être réouverte.

Evidement, cela imposerait vraisemblablement  une complexification de l'architecture de la chaine de communication. C'est-à-dire qu'il faudrait intégrer un module maître I2C par élément dans une utilisation FPGA ou microcontrôleur, ce qui a voulu être évité au départ...

\section{Capteurs et actionneurs}
\subsection{Commutateurs et afficheurs}
En raison de l'avancement du projet, nous avions décidé d'utiliser les circuits PCF8575 afin d'interfacer les boutons poussoirs,
commutateurs à positions et diodes en raison de la date butoire imposée lors du lancement du projet. Néanmoins une
deuxième solution consistant à utiliser le FPGA. Dans ce cas il faudra implanter un routage qui permettrait
d'interfacer les boutons poussoirs et les diodes sous forme de deux matrices (une matrice pour chaque).
Dans le cas des boutons poussoirs le fonctionnement serait exactement le même que pour le clavier du FMC.
Pour les diodes, le FPGA alumerait les diodes voulues en fonction des informations reçues depuis le BECK. Il serait
en quelque sorte une interface de multiplexage des diodes. Par contre les commutateurs eux ne pourront pas être
interfacés via un clavier matriciel à cause de leurs caractéristiques électriques. En effet, il serait alors impossible
de détecter un changement de position.
